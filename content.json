{"posts":[{"title":"Algorithm [0] Sequential Tables","text":"Structure: Sequential table is structure that store all the element in a continous space. In C Language, we could use structure type to define a sequential tables: 1234567#define Type inttypedef struct { Type * head; // used to store the pointer of the first element int size; // used to record the number of elements stored int capacity; // used to record the capacity of tables} Table; Usage: Init table: 1234567891011121314#define Defaul_Size 8void TableInit (Table* t) { t-&gt;head = (Type *)malloc(Default_Size * sizeof(Type)); // test if the space allocation is successful. if (!t-&gt;head) { printf(&quot;Error occurs while space allocation.&quot;); exit(1); } t-&gt;size = 0; t-&gt;capacity = Default_Size;} Add element: 12345678910111213int TableAdd (Table* t, Type e) { if (t-&gt;capacity &gt; t-&gt;size) { t-&gt;size++; t-&gt;head[t-&gt;size-1] = e; // succeed to delete element return 1; }else{ // failed to add element return 0; }} Delete element: 1234567891011121314int TableDel (Table* t, int index) { // test for the valid index if (t-&gt;size &amp;&amp; index&gt;=0 &amp;&amp; t-&gt;size&gt;index) { for (int i=index;i&lt;t-&gt;size-1;i++) t-&gt;head[i] = t-&gt;head[i+1]; t-&gt;size--; // succeed to delete element return 1; }else{ // failed to delete element return 0; }} Search element: 123456789int TableSearch (Table t, Type e) { // test for the valid index if (t.size) { for (int i=0;i&lt;t.size;i++) if(t.head[i]==e) return i; } // failed to delete element return -1; }} Free table: 123456789void TableFree (Table* t) { if (t-&gt;head != NULL) { free(t-&gt;head); t-&gt;head = NULL; } t-&gt;size = 0; t-&gt;capacity = 0;} Example: 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;sequentialTables.h&quot;int main (void) { Table t = {NULL, 0, 0}; // Init the table TableInit(&amp;t); // Add elements for (int i=0;i&lt;5;i++) TableAdd(&amp;t, i); // Show the table for (int i=0;i&lt;t.size;i++) printf(&quot;%d &quot;, t.head[i]); // Delete certain element TableDel(&amp;t, 3); for (int i=0;i&lt;t.size;i++) printf(&quot;%d &quot;, t.head[i]); // Search certain element index = TableSearch(t, 3); if (index&gt;0) printf(&quot;\\tGot it, index is %d\\n&quot;, index); else printf(&quot;\\tFailed to search.\\n&quot;); // Free the table TableFree(&amp;t); return 0;}","link":"/Algorithm-0-Sequential-Tables.html"},{"title":"Anaconda Installation","text":"Introduction Anaconda is an open source, user-friendly and trusted Python distribution, which is the world’s preferred distribution for numerical and scientific computing. It contains more than 6,000 Python libraries to do with data visualization, ML, Deep Learning and data science. It provides a comprehensive and easy-to-use platform that includes a powerful package and environment management system. One of the key features of Anaconda is its package management system called “conda.” Conda allows users to easily install, update, and manage a wide range of packages and dependencies required for data analysis and scientific computing. It simplifies the process of setting up and maintaining a consistent working environment across different platforms. Anaconda also includes a collection of over 1,500 pre-built and optimized scientific packages and libraries.(which I like most! 😃) These packages cover various domains such as data manipulation, visualization, machine learning, and deep learning. Some of the popular packages included in Anaconda are NumPy, Pandas, Matplotlib, scikit-learn, and TensorFlow. In addition to package management, Anaconda provides a user-friendly integrated development environment (IDE) called Anaconda Navigator. The Navigator offers a graphical interface for managing environments, launching applications, and exploring available packages and documentation. It is particularly helpful for beginners who want to get started with data science without dealing with complex command-line tools. Anaconda supports multiple operating systems, including Windows, macOS, and Linux, making it accessible to a wide range of users. It is widely used by data scientists, researchers, and developers in academia, industry, and the open-source community. Overall, Anaconda is a comprehensive and versatile platform that simplifies the process of setting up and managing data science environments. It provides a rich ecosystem of packages and tools, making it an essential resource for anyone working in the field of data science and machine learning. Installation with Windows 1. Download the Anaconda installer original source Ali Disk for those who have no access to official website 2. Open the Anaconda installer Next I Agree Though “Just Me” option is recommended , but I’d like to choose “All Users” for the later convenience, so you can choose as your willingness. Type the path you want to install the Anaconda. I recommend to install the program in the different disk with System Disk (C:), for instance, Disk D is a really good option. Select both check boxes. Install 3. Check the installation Open the terminal press Win+R type “cmd” press Enter to open the terminal Open Python Interpreter type “python” in the terminal press Enter to run the command if your terminal becomes like the following picture, then your Anaconda environment installation has accomplished.","link":"/Anaconda-Installation.html"},{"title":"Assembler Jump Instructions","text":"1. Unconditional Jump 1jmp ;unconditinal jump 2. Jump according to CX、ECX registers 12jcxz ;jump if CX is 0jecxz ;jump if ECX is 0 3. Jump according to Flag bits Relavent PSW Flag bits 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF - AF - PF - CF Overflow Direction Interrupt Trap Sign Zero - Assistance - Parity - Carry Jump according the PSW flags 12345678910111213141516jz ;jump if ZF flag is 1jnz ;jump if ZF flag is 0jc ;jump if CF flag is 1jnc ;jump if CF flag is 0jo ;jump if OF flag is 1jno ;jump if OF flag is 0js ;jump if SF flag is 1jns ;jump if SF flag is 0jp ;jump if PF flag is 1jnp ;jump if PF flag is 0jpe ;jump like JPjpo ;jump like JNP Jump according the comparision Equvalent12je ; == jump like JZjne ; != jump like JNZ Usigned Comparision1234567891011ja ; &gt;jna ; !&gt; (&lt;=)jae ; &gt;= jump like JNBjnae ; !&gt;= (&lt;) jump like JBjb ; &lt;jnb ; !&lt; (&gt;=)jbe ; &lt;= jump like JNAjnbe ; !&lt;= (&gt;) jump like JA Signed Comparision1234567891011jl ; &lt;jnl ; !&lt; (&gt;=)jle ; &lt;= jump like JNGjnle ; !&lt;= jump like JGjg ; &gt;jng ; !&gt; (&lt;=)jge ; &gt;= jump like JNLjnge ; !&gt;= (&lt;) jump like JL","link":"/Assembler-Jump-Instructions.html"},{"title":"Algorithm [1] Quick Sort","text":"了解快速排序算法: 快速排序是一种基于分治思想的排序算法。它选择一个基准元素，并将待排序序列分成两个子序列，一个小于基准元素的子序列和一个大于基准元素的子序列。然后递归地对这两个子序列进行排序，最终将整个序列排序完成。 快速排序的优势: 高效性: 平均时间复杂度为$O(nlogn)$ 最坏情况下的时间复杂度为 $O(n^2)$。 原地排序: 不需要额外的存储空间。 快速排序展示 动图展示 代码展示 递归法12345678910111213141516171819202122232425262728void swap(int *x, int *y) { int t = *x; *x = *y; *y = t;}void quick_sort_recursive(int arr[], int start, int end) { if (start &gt;= end) return; int mid = arr[end]; int left = start, right = end - 1; while (left &lt; right) { while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++; while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--; swap(&amp;arr[left], &amp;arr[right]); } if (arr[left] &gt;= arr[end]) swap(&amp;arr[left], &amp;arr[end]); else left++; if (left) quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end);}void quick_sort(int arr[], int len) { quick_sort_recursive(arr, 0, len - 1);} 迭代法12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct _Range { int start, end;} Range;Range new_Range(int s, int e) { Range r; r.start = s; r.end = e; return r;}void swap(int *x, int *y) { int t = *x; *x = *y; *y = t;}void quick_sort(int arr[], const int len) { if (len &lt;= 0) return; // 避免len等於負值時引發段錯誤（Segment Fault） // r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素 Range r[len]; int p = 0; r[p++] = new_Range(0, len - 1); while (p) { Range range = r[--p]; if (range.start &gt;= range.end) continue; int mid = arr[(range.start + range.end) / 2]; // 選取中間點為基準點 int left = range.start, right = range.end; do { while (arr[left] &lt; mid) ++left; // 檢測基準點左側是否符合要求 while (arr[right] &gt; mid) --right; //檢測基準點右側是否符合要求 if (left &lt;= right) { swap(&amp;arr[left],&amp;arr[right]); left++;right--; // 移動指針以繼續 } } while (left &lt;= right); if (range.start &lt; right) r[p++] = new_Range(range.start, right); if (range.end &gt; left) r[p++] = new_Range(left, range.end); }} 快速排序在处理大规模数据时效果显著，但对于小规模数据可能不如其他简单排序算法。 在实现快速排序时，要注意处理边界情况和避免无限递归。","link":"/Algorithm-1-Quick-Sort.html"},{"title":"Breadboard Usage","text":"本文转载自面包板使用简介 &lt;CSDN&gt; 面包板是实验室中用于搭接电路的重要工具，熟练掌握面包板的使用方法是提高实 验效率，减少实验故障出现几率的重要基础之一。下面就面包板的结构和使用方法做简单介绍。 面包板的外观和内部结构如图 1 所示，常见的最小单元面包板分上、中、下三部分， 上面和下面部分一般是由一行或两行的插孔构成的窄条，中间部分是由中间一条隔离凹 槽和上下各 5 行的插孔构成的宽条。 对上面和下面部分的窄条，外观和结构如图 2: 窄条上下两行之间电气不连通。每 5 个插孔为一组，通常的面包板上有 10 组或 11 组。对于 10 组的结构，左边 5 组内部电气连通，右边 5 组内部电气连通，但左右两边 之间不连通，这种结构通常称为 5-5 结构。还有一种 3-4-3 结构即左边 3 组内部电气连 通，中间 4 组内部电气连通，右边 3 组内部电气连通，但左边 3 组、中间 4 组以及右边 3 组之间是不连通的。对于 11 组的结构，左边 4 组内部电气连通，中间 3 组内部电气连 通，右边 4 组内部电气连通，但左边 4 组、中间 3 组以及右边 4 组之间是不连通的，这 种结构称为 4-3-4 结构。 中间部分宽条是由中间一条隔离凹槽和上下各 5 行的插孔构成。在同一列中的 5 个 插孔是互相连通的，列和列之间以及凹槽上下部分则是不连通的。外观及结构如图 3: 在做模拟电路实验的时候，通常是使用两窄一宽组成的小单元，同学们应按照实验指导教师的示范和要求，在宽条部分搭接电路的主体部分，上面的窄条取一行做电源，下面的窄条取一行做接地。使用时注意窄条的中间部分不通。在搭接数字电路时，有时由于电路的规模较大，需要多个宽条和窄条组成的较大的 面包板，但在使用时同样通常是两窄一宽同时使用，两个窄条的第一行一般和地线连接， 第二行和电源相连。由于集成块电源一般在上面，接地在下面，如此布局有助于将集成 块的电源脚和上面第二行窄条相连，接地脚和下面窄条的第一行相连，减少连线长度和跨接线的数量。中间宽条用于连接电路，由于凹槽上下是不连通的，所以集成块一般跨 插在凹槽上。具体参看图 4、5。","link":"/Breadboard-Usage.html"},{"title":"CMake[1] Basic Usage","text":"Environment Suppose we have the source files in the directory aim aim: \\ -- hello.c -- CMakeLists.txt The version I used in my CMake Learning series is ‘CMake 3.25.1’ Basic Usage For starters, let us consider the simplest CMakeLists file. To compile an executable from one source file, the CMakeLists file would contain two lines: project (Hello) add_executable (Hello Hello.c) project : indicate the name of the resulting workspace add_executable : add an executable target to the build process if your project requres several files ,it’s easy to modify with lines below. add_executable (Hello File1.c File2.c File3.c) Advanced a little bit Now, let’s consider the more complicated example below. cmake_minimum_required (3.0) project (HELLO) set (HELLO_SRCS File1.c File2.c File3.c) if (WIN32) set (HELLO_SRCS $(HELLO_SRCS) WinSupport.c) else () set (HELLO_SRCS $(HELLO_SRCS) UnixSupport.c) endif () # Look for the Tcl library find_library (TCL_LIBRARY NAMES tcl tcl84 tcl83 tcl82 tcl80 PATHS /opt/TclTk/lib c:/TclTk/lib ) if (TCL_LIBRARY) target_link_library (Hello ${TCL_LIBRARY}) endif () At first, Cmake will test the version of itself according to the cmake_minimum_required function. Then it will make all the source file a list and assign it to HELLO_SRCS. And, the conditional judgement will judge the type of the OS, and add the appropriate support file into the HELLO_SRCS. Finally, with the Tcl library assigned to TCL_LIBRARY, target_link_library will link the lib to the Hello executable target. Run the cmake 1.1 Running CMake’s Qt Interface Installation on Kali: $ sudo apt install cmake-qt-gui Run it : $ cmake-gui 1.2 Running the ccmake Curses Interface Installation on Kali: $ sudo apt install cmake-curses-gui Run it : $ ccmake ../cmake_test_1 make it : $ make","link":"/CMake-1-Basic-Usage.html"},{"title":"CMake[2] CMake Language","text":"Comment: # xxxxxx Basic Commands: project (projectname [C] [CXX] [Fortran] [NONE]) the top-level CMakeLists files should call the PROJECT command. This command both names the project and optionally specifies which languages will be used by it. set/unset the command manipulates variables and entries in the persistent cache. string, list, remove, sepatate_arguments the commands offer basic manipulation of strings and lists. add_executable, add_library the basic commands to define the executables and libraries to build and which files comprise them. target_link_libraries (&lt;target&gt; LINK_INTERFACES_LIBRARIES [[debug|optimized|general] &lt;lib&gt;]...) link the libs to the target. Flow Control: Conditional Statements : 12345if (FOO) if (FOO) # do something here # do something hereelse () or else (FOO) # do something else # do something elseendif () endif (FOO) condition operations include : Not AND OR EQUAL LESS GREATER STREQUAL STRLESS STRGREATER VERSION_EQUAL VERSION_LESS VERSION_GREATER Looping Constructs : foreach:123foreach (i ....) # do somethingendforeach (i) while:123while (CONDITION) # do somethingendwhile () Procedure Definitions : function: 123function (Func_name Func_Args) # do somethingendfunction () macro: 123macro (Macro_name Macro_Args) # do somethingendmacro () The main differences are that a macro does not push and pop a new variable scope, and that the arguments to a macro are not treated as variables but as strings replaced prior to execution. And the macro supports defining macros that take variable argument lists. The variable arguments can be referenced using ARGC (the number of arguments), ARGV (a list of all the arguments), ARGN (a list of all the arguments after the formal arguments). Interrupt Commands: break return","link":"/CMake-2-CMake-Language.html"},{"title":"CMake[3] Installing Files","text":"Software is typically installed into a directory sepatate from the source and build trees. This allows it ro be distributed in a clean form and isolates users from the details of the build process.CMake provides the install command to specify how a project is to be installed. usage: 1234567install(TARGETS MyLib EXPORT MyLibTargets LIBRARY DESTINATION lib # the destination path of dynamic-link library ARCHIVE DESTINATION lib # the destination path of static library RUNTIME DESTINATION bin # the destination path of executable PUBLIC_HEADER DESTINATION include # the destination path of header file ) The argument LIBRARY ARCHIVE RUNTIME PUBLIC_HEARDER is optional which can be chosen according to your needs. The path after DESTINATION is customizable, and the default parent path is set in CMAKE_INTSTALL_PREFIX, which can be changed by set command. The default value of CMAKE_INSTALL_PREFIX is: /usr/local on Unix-like system C:/Program Files/${PROJECT_NAME} The TARGETS keyword is immediately followed by a list of the targets created using add_executable and add_library commands. And targets files are categories as follows: RUNTIME executable dynamic-link library LIBRARY loadable modules shared libraries ARCHIVE import libraries static libraries Project may install files other than those are created with add_executable or add_library, such as hearder files or documentation. General-purpose installation of files is specified using the FILES signature: 123456install(FILES files ... DESTINATINO &lt;dir&gt; PERMISSION permissions... CONFIGURATIONS [Debug|Release|...] COMPONENT &lt;component&gt; RENAME &lt;name&gt;) The other similar signatures are PROGRAMS, DIRECTORY, SCRIPT and CODE.","link":"/CMake-3-Installing-Files.html"},{"title":"Change the Render of Hexo Markdown","text":"The article is translated from 【Hexo】选择更高级的Markdown渲染器 by Xavier Jiezou from CSDN Introdeuction Since there are some problems of my default blog renderer – hexo-renderer-marked, like being not able to show html charactor &amp;emsp;, I decide to change the renderer to a better one – hexo-renderer-markdown-it. Installation uninstall hexo-renderer-marked 1npm un hexo-renderer-marked --save install hexo-renderer-marked 1npm i hexo-renderer-markdown-it --save If your npm gets stuck there, you can change your repository to accelarate it. install some plugins 123npm i hexo-checkboxnpm i hexo-imsizenpm i hexo-expandable other plugins are contained by hexo-renderer-markdown-it itself, and you shouldn’t install them manually. Configuration append the following text at the end of Hexo configuration file _config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142markdown: preset: &quot;default&quot; render: html: true xhtmlOut: false langPrefix: &quot;language-&quot; breaks: true linkify: true typographer: true quotes: &quot;“”‘’&quot; enable_rules: disable_rules: plugins: - markdown-it-abbr - markdown-it-cjk-breaks - markdown-it-deflist - markdown-it-emoji - markdown-it-footnote - markdown-it-ins - markdown-it-mark - markdown-it-sub - markdown-it-sup - markdown-it-checkbox - markdown-it-imsize - markdown-it-expandable - name: markdown-it-container options: success - name: markdown-it-container options: tips - name: markdown-it-container options: warning - name: markdown-it-container options: danger anchors: level: 2 collisionSuffix: &quot;&quot; permalink: false permalinkClass: &quot;header-anchor&quot; permalinkSide: &quot;left&quot; permalinkSymbol: &quot;¶&quot; case: 0 separator: &quot;-&quot; Usage Basic Name Description Syntax Example markdown-it-abbr Comment *[Name]: the name of someting *[Name]: the name of someting markdown-it-emoji Emoji :) 😃 markdown-it-footnote Footnote Reference literature[^1] Reference literature[^1] markdown-it-ins Underline ++underline++ underline markdown-it-mark Highlight ==Mark== Mark markdown-it-sub Sub Mark H~2~O H2O markdown-it-sup Sup Mark x^2^ x2 markdown-it-checkbox CheckBox unchecked: - [ ] checked: - [x] Unchecked Checked Advanced markdown-it-imsize : customize the size of an image format ![test](image.png =100x200) ouput &lt;p&gt;&lt;img src=&quot;image.png&quot; alt=&quot;test&quot; width=&quot;100&quot; height=&quot;200&quot;&gt;&lt;/p&gt; markdown-it-expandable : fold/unfold the content format 123+++ **Click to fold**The content to be hidden.+++ ouput &nbsp;Click to foldThe content to be hidden. markdown-it-container : customize the container format 12345678910111213141516171819::: tips**Tips**This is a tip.:::::: warning**Warning**This is a warning.:::::: danger**Danger**This is a danger warning.:::::: success**Success**This is a surccess container.::: output Tips This is a tip. Warning This is a warning. Danger This is a danger warning. Success This is a surccess container. addition you should add the following CSS content to the Style Configuration Files (e.g. ./node_modules/hexo-theme-icarus/source/css/default.styl). Otherwise, the backgroud color effect won’t work. 123456789101112131415161718192021222324.tips { padding-left: 10px; background-color rgba(52,152,219,.3); border-left 4px solid rgb(52,152,219); color: darken(rgb(52,152,219),20%);}.success { padding-left: 10px; background-color rgba(46,204,113,.3); border-left 4px solid rgb(46,204,113); color: darken(rgb(46,204,113),20%);}.warning { padding-left: 10px; background-color rgba(241,196,15,.3); border-left 4px solid rgb(241,196,15); color: darken(rgb(241,196,15),20%);}.danger { padding-left: 10px; background-color rgba(231,76,60,.3); border-left 4px solid rgb(231,76,60); color: darken(rgb(231,76,60),20%);}","link":"/Change-the-Render-of-Hexo-Markdown.html"},{"title":"Conver the image file to icon file","text":"With Python we can easily convert any image to icon file. 12345from PIL import Imageimg = Image.open(&quot;the path to your image&quot;)# icon_sizes = [(16, 16), (32, 32), (48, 48), (64, 64)]sizes = [(64, 64)]img.save(&quot;the destination path for icon file&quot;, sizes=sizes)","link":"/Conver-the-image-file-to-icon-file.html"},{"title":"Hexo Compress -- hexo-neat plugin","text":"Beacause of the bug of converting md to html, there are quite lots of verbose blank charactor in html files, which make Hexo Pages loading is quite slow, and the waiting is agonizing. So for more smooth use of Hexo. I decide to use hexo-neat plugin by rozbo to accelerate my blog load process. Preference 使用gulp精简hexo博客代码 Hexo-Neat介绍 Introduction of Hexo-Neat Author : rozbo Compress Method: Plugin Source neat-html HTMLMinifier neat-css clean-css neat-js UglifyJS Installation install the plugin in the root directory 1npm install hexo-neat --save append the neat configuration in the end of _config.yml 1234567891011121314151617181920212223neat_enable: true# compress htmlneat_html: enable: true exclude:# compress cssneat_css: enable: true exclude: - '**/*.min.css'# compress jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js Test $ hexo clean &amp;&amp; hexo g","link":"/Hexo-Compress-hexo-neat-plugin.html"},{"title":"Install VSIX plugin of VS Code","text":"Reprint : VS Code 安装 VSIX 插件 There are diverse Extentions in the VS Code Marketplace and you can install them easily just by clicking Install button. But there are some plugins not released to Marketplace but packing to VSIX file. The following is several ways to install those plugins. Way 1 In the Extention, click the upper right corner, and click Install from VSIX. In the pop-up file selection interface, find the vsix file you want to install and click install to install. After the installation, the lower right corner will pop the notification of successful installation. Way 2 Press Ctrl+Shift+P Type install from … Choose Extentions: Install from VSIX Way 3 Open your Terminal Type code --install-extension xx.vsix Run the command 1Extension 'xxx.vsix' was successfully installed. Restart VSCode and you can see the plugin has been installed to Extensions.","link":"/Install-VSIX-plugin-of-VS-Code.html"},{"title":"Linux Commands : source","text":"Usage: 123source FileName# or. FileName Purpose: Read and run your commands in the FileName in the current bash environment. source is built-in commands of bash shell, and you could also execute it by dot “.” which run as source. Imagine such a scenario: you have a file named a.sh in which there is “export $Variable=1”, and you run it by ./a.sh. After that, you type echo $Variable, but there is nothing returned. But if you run the bash file by source, your command of echo gets 1. That’s because souce commands will run bash commands in the current bash environment, but ./a.sh will run your code in the sub-shell.","link":"/Linux-Commands-source.html"},{"title":"Make Your Own Neuralnetwork","text":"In these days, I’ve read book named Make your own neuralnetwork by Tariq Rashid. The author use the vivid and simplest words to teach how to build a neuralnetwork with high-school-level math as well as a little bit knowledge of Martix. It’s interesting to build my own network and it runs well and the accuracy rate is quite high.The followings are the steps to build your own neuralnetwork and use it to recognize the MNIST dataset. 1. MNIST Database MNIST database is a large datset of handwritten digits that is commonly used for training and testing machine learning models. The dataset consists of 60,000 training images and 10,000 testing images, each of size 28 $\\times$ 28 pixels. The images are grayscale and show a single digit from 0 to 9. The following is pic: The following is the content of csv file; In the csv files, each training sample in a row consists of lable (first digit), and the greyscale of image (following 784 digits) 2. Build NeuralNetwork 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npfrom scipy.special import expit as Sclass NeuralNetwork:# This neuralnetwork is initially designed as a input-hidden-output model def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate) -&gt; None: # Ready the network configurations self.lr = learningrate self.inputnodes = inputnodes self.hiddennodes = hiddennodes self.outputnodes = outputnodes self.w_ih = np.random.normal(0.0, pow(self.hiddennodes, -0.5), (self.hiddennodes, self.inputnodes)) self.w_ho = np.random.normal(0.0, pow(self.hiddennodes, -0.5), (self.outputnodes, self.hiddennodes)) self.activation_func = S def train_single(self, input_list, target_list): # Train the neural-network with a given single data record inputs = np.array(input_list, ndmin=2).T targets = np.array(target_list, ndmin=2).T hidden_inputs = np.dot(self.w_ih, input_list) hidden_outputs = self.activation_func(hidden_inputs).reshape((100, 1)) final_inputs = np.dot(self.w_ho, hidden_outputs) final_outputs = self.activation_func(final_inputs).reshape((10, 1)) # Get the error data error_outputs = targets-final_outputs error_hidden = np.dot(self.w_ho.T, error_outputs) # Modify the weight bettween neuros self.w_ho += self.lr * np.dot((error_outputs * final_outputs * (1.0 - final_outputs)), np.transpose(hidden_outputs)) self.w_ih += self.lr * np.dot((error_hidden * hidden_outputs * (1.0 - hidden_outputs)), np.transpose(inputs)) def train(self, input_lists, target_lists, cycle=1, show_status:bool = False): for x in range(cycle): for i in range(len(target_lists)): self.train_single(data_train_value[i], data_train_target[i]) print(&quot;\\tTraining Prcessing: (cycle: &quot;, x+1, &quot;/&quot;, cycle, &quot;)&quot;) def query(self, input_list): inputs = np.array(input_list, ndmin=2).T inputs_hidden = np.dot(self.w_ih, inputs) outputs_hidden = self.activation_func(inputs_hidden) inputs_final = np.dot(self.w_ho, outputs_hidden) outputs_final = self.activation_func(inputs_final) return outputs_final After building a network, the following work is ready the data: by the way the structure of my project is : MyNeuralWork \\ -- main.py -- data \\ -- mnist_train.csv -- mnist_test.csv 123456789101112131415161718192021222324252627282930313233343536373839404142import pandas as pddef get_train_data(): # Version 1.0 # with open('./data/mnist_train.csv', 'r') as file: # data = file.readlines() # train_data = [] # target_data = [] # for image in data: # d = image.split(',') # train = np.asfarray(d[1:]) / 255.0 * 0.99 + 0.01 # train_data.append(train) # target = np.zeros(output_nodes) + 0.01 # target[int(d[0])] = 0.99 # target_data.append(target) # The Primary method of getting csv files is too ugly , I'd like to use pandas file_train = pd.read_csv('./data/mnist_train.csv', header=None, dtype='float').values # Normalize the data into the interval (0, 1) data_value = np.asfarray(file_train[:, 1:]) / 255.0 * 0.99 +0.01 data_target_pre = np.asfarray(file_train[:, 0]) data_target = [] for i in range(len(data_target_pre)): a = np.zeros(output_nodes) + 0.01 a[int(data_target_pre[i])] = 0.99 data_target.append(a) return data_target, data_valuedef get_test_data(): # File input method is same as done above. file_test = pd.read_csv('./data/mnist_test.csv', header=None, dtype='float').values # Normalize the data into the interval (0, 1) data_value = np.asfarray(file_test[:, 1:]) / 255.0 * 0.99 +0.01 data_target = np.asfarray(file_test[:, 0]) return data_target, data_value Now we get the function of getting train data and test data, let’s structure the whole code to finish MNIST training. 123456789101112131415161718192021222324252627282930313233# Configurate the date of networkinput_nodes = 784hidden_nodes = 100output_nodes = 10learning_rate = 0.3network = NeuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)# Get the MNIST datadata_train_target, data_train_value = get_train_data()data_test_target, data_test_value = get_test_data()# Data of model-trainingCYCLE = 20# Train the modelprint(&quot;Start training:&quot;)network.train(data_train_value, data_train_target, 20, show_status=True)print(&quot;\\tTraining is finisheed.&quot;)# Test the modelprint(&quot;Start testing:&quot;)correct = 0whole = len(data_test_target)for i in range(whole): answer_list = network.query(data_test_value[i]) answer = int(answer_list.argmax()) if data_test_target[i] == answer: correct += 1print('\\tTesting is finished.')print(&quot;The model accuracy rate is &quot;, correct / whole * 100, '%') Let’s run the code: 12345678910111213141516171819202122232425Start training: Training Prcessing: (cycle: 1 / 20 ) Training Prcessing: (cycle: 2 / 20 ) Training Prcessing: (cycle: 3 / 20 ) Training Prcessing: (cycle: 4 / 20 ) Training Prcessing: (cycle: 5 / 20 ) Training Prcessing: (cycle: 6 / 20 ) Training Prcessing: (cycle: 7 / 20 ) Training Prcessing: (cycle: 8 / 20 ) Training Prcessing: (cycle: 9 / 20 ) Training Prcessing: (cycle: 10 / 20 ) Training Prcessing: (cycle: 11 / 20 ) Training Prcessing: (cycle: 12 / 20 ) Training Prcessing: (cycle: 13 / 20 ) Training Prcessing: (cycle: 14 / 20 ) Training Prcessing: (cycle: 15 / 20 ) Training Prcessing: (cycle: 16 / 20 ) Training Prcessing: (cycle: 17 / 20 ) Training Prcessing: (cycle: 18 / 20 ) Training Prcessing: (cycle: 19 / 20 ) Training Prcessing: (cycle: 20 / 20 ) Training is finisheed.Start testing: Testing is finished.The model accuracy rate is 94.06 % we can see the accuracy rate is up to 94%, it’s really amazing for me (a green hand for Deeplearning).","link":"/Make-Your-Own-Neuralnetwork.html"},{"title":"Markdown Math Tokens","text":"Frequently Used Symbols: Name Code Render Effect Infinity \\infty or \\infini $\\infty$ Empty Set \\empsey or \\varnothing $\\emptyset$or$\\varnothing$ In \\in or \\ni $\\in$ or $\\ni$ Not In \\notin $\\notin$ Subset \\subseteq $\\subseteq$ Subset But Not Equal \\subsetneqq $\\subsetneqq$ Superset \\supset $\\supseteq$ Superset But Not Equal \\supsetneqq $\\supsetneqq$ Intersection \\cap $\\cap$ Union \\cup $\\cup$ Equal = $=$ Not Equal \\neq or \\not = $\\neq$ or $\\not =$ Greater Than \\geq or \\geqq or \\geqslant $\\geq$ or $\\geqq$ or $\\geqslant$ Less Than \\leq or \\leqq or \\leqslant $\\leq$ or $\\leqq$ or $\\leqslant$ Not \\neg $\\neg$ And \\land $\\land$ Or \\lor $\\lor$ Exisit \\exists $\\exists$ Exisit Only One \\exists! $\\exists!$ For All \\forall $\\forall$ Derive \\Rightarrow or \\Longrightarrow $\\Rightarrow$ or $\\Longrightarrow$ Be Derived \\Leftarrow or \\Longleftarrow $\\Leftarrow$ or $\\Longleftarrow$ Vector \\vec{v} or \\overrightarrow{v} $\\vec{v}$ or $\\overrightarrow{v}$ Perpendicular \\perp $\\perp$ Not Perpendicular \\not\\perp $\\not\\perp$ Parallel \\parallel $\\parallel$ Not Parallel \\nparallel $\\nparallel$ Similar \\sim $\\sim$ Congruence \\cong $\\cong$ Angle \\angle $\\angle$ Triangle \\triangle or \\triangledown \\triangleright or \\triangleleft $\\triangle$ or $\\triangledown$ $\\triangleright$ or $\\triangleleft$ Plus Minus \\pm $\\pm$ Minus Plus \\mp $\\mp$ Multiply \\times $\\times$ Divide \\div $\\div$ Dot Product \\cdot $\\cdot$ Ellipsis \\cdots $\\cdots$ Fraction \\frac{a}{b} or \\dfrac{a}{b} $\\frac{a}{b}$ or $\\dfrac{a}{b}$ Root \\sqrt[n]{x} $\\sqrt[n]{x}$ Integral \\int_{a}^{b} $\\int_{a}^{b}$ Limit \\lim\\limits_{x \\rightarrow \\infty}a $\\lim\\limits_{x \\rightarrow \\infty}a$ Add \\sum_{i=0}^{n}a $\\sum_{i=0}^{n}a$ Product \\prod_{i=0}^{n}a $\\prod_{i=0}^{n}a$ Logarithm \\log_{n}a or \\ln or \\lg $\\log_{n}a$ or $\\ln$ or $\\lg$ Trignometric Function \\sin or \\sec or \\tan \\cos or \\csc or \\cot $\\sin$ or $\\sec$ or $\\tan$ $\\cos$ or $\\csc$ or $\\cot$ Because \\because $\\because$ Therefore \\therefore $\\therefore$ Overline \\overline{a+b+c} $\\overline{a+b+c}$ Underline \\underline{a+b+c} $\\underline{a+b+c}$ Upper Bracket \\overbrace{a+ \\cdots +a}^{x} $\\overbrace{a+ \\cdots +a}^{x}$ Under Bracket \\underbrace{a+ \\cdots +a}_{x} $\\underbrace{a+ \\cdots +a}_{x}$ Tokens \\hat{x} or \\check{x} or \\breve{x} $\\hat{x}$ or $\\check{x}$ or $\\breve{x}$ Space &amp;emsp; or &amp;ensp; or &amp;nbsp; x x Equivalent \\equiv $\\equiv$","link":"/Markdown-Math-Tokens.html"},{"title":"NodeJS Mirror Source","text":"To change Node.js mirror/source, you can follow these steps: Open a terminal or command prompt. Use the following command to set the registry to your preferred mirror/source: 1npm config set registry [mirror/source URL] For example, if you want to use the mirror/source provided by Taobao, you can run: 1npm config set registry https://registry.npm.taobao.org Verify the configuration by running: 1npm config get registry This should output the URL of the mirror/source you just set. That’s it! Now Node.js and npm will use your preferred mirror/source for package installation and updates.","link":"/NodeJS-Mirror-Source.html"},{"title":"Linux Commands:sudo","text":"Usage 123456789101112131415161718192021222324252627282930313233343536373839404142434445sudo - execute a command as another userusage: sudo -h | -K | -k | -Vusage: sudo -v [-ABknS] [-g group] [-h host] [-p prompt] [-u user]usage: sudo -l [-ABknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]usage: sudo [-ABbEHknPS] [-r role] [-t type] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user] [VAR=value] [-i|-s] [&lt;command&gt;]usage: sudo -e [-ABknS] [-r role] [-t type] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user] file ...Options: -A, --askpass use a helper program for password prompting -b, --background run command in the background -B, --bell ring bell when prompting -C, --close-from=num close all file descriptors &gt;= num -D, --chdir=directory change the working directory before running command -E, --preserve-env preserve user environment when running command --preserve-env=list preserve specific environment variables -e, --edit edit files instead of running a command -g, --group=group run command as the specified group name or ID -H, --set-home set HOME variable to target user's home dir -h, --help display help message and exit -h, --host=host run command on host (if supported by plugin) -i, --login run login shell as the target user; a command may also be specified -K, --remove-timestamp remove timestamp file completely -k, --reset-timestamp invalidate timestamp file -l, --list list user's privileges or check a specific command; use twice for longer format -n, --non-interactive non-interactive mode, no prompts are used -P, --preserve-groups preserve group vector instead of setting to target's -p, --prompt=prompt use the specified password prompt -R, --chroot=directory change the root directory before running command -r, --role=role create SELinux security context with specified role -S, --stdin read password from standard input -s, --shell run shell as the target user; a command may also be specified -t, --type=type create SELinux security context with specified type -T, --command-timeout=timeout terminate command after the specified time limit -U, --other-user=user in list mode, display privileges for user -u, --user=user run command (or edit file) as specified user name or ID -V, --version display version information and exit -v, --validate update user's timestamp without running a command -- stop processing command line arguments Purpose In Linux, typically only the root user is allowed to perform system-level tasks that require special privileges, such as installing software or modifying system settings. However, to make it convenient for other users to perform these tasks without switching to the root account, Linux provides the sudo command. The sudo command allows non-superusers to execute specified commands as the superuser, provided that they are authorized to use sudo in the sudoers file.By default, only system administrators or users with sudo privileges can modify the sudoers file. Therefore, only users who have been explicitly granted sudo access in the sudoers file can use the sudo command. User’s sudo access can be added or removed by editing the /etc/sudoers file or using the visudo command. In general, we use sudo to run a command as root user when the user authority required such as modify the files in /etc or etc.But It is agonizing to type password every time you use sudo command and you can skip the password asking process by configurating as follows: Method One: add your user into the sudo group # useradd -aG sudo &lt;username&gt; Method Two: add a line of following code at the end of the /etc/sudoers file &lt;username&gt; ALL=(ALL:ALL) NOPASSWD:ALL","link":"/Linux-Commands-sudo.html"},{"title":"Oh-my-zsh Installation","text":"Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout… \"Oh My ZSH!\" What is Oh My Zsh? Oh My Zsh is an open source, community-driven framework for managing your Zsh configuration. Sounds boring. Let’s try again. Oh My Zsh will not make you a 10x developer…but you may feel like one! Once installed, your terminal shell will become the talk of the town or your money back! With each keystroke in your command prompt, you’ll take advantage of the hundreds of powerful plugins and beautiful themes. Strangers will come up to you in cafés and ask you, “that is amazing! are you some sort of genius?” Finally, you’ll begin to get the sort of attention that you have always felt you deserved. …or maybe you’ll use the time that you’re saving to start flossing more often. 😬 How to install oh-my-zsh 1. Install zsh shell 123$ sudo apt install zsh# change the default shell to zsh$ chsh -s /bin/zsh &lt;username&gt; 2. Install oh-my-zsh 123456# get the installation shell scriptswget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh# change the executable permissionchmod +x install.sh# run it./install.sh 3. Configurate ZSH install the plugins zsh-syntax-highlighting 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting if your web is blocked for github.com you can use 1git clone https://gitee.com/zjy_1671/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting zsh-autosuggestions 1git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions if your web is blocked for github.com you can use 1git clone https://gitee.com/zjy_1671/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting configurate .zshrc open the configuration file 1vim ~/.zshrc change the content .zshrc1234567- plug=(git)+ plug=(+ git+ sudo+ zsh-syntax-highlighting+ zsh-autosuggestions+ ) change the theme .zshrc12- ZSH_THEME=&quot;robbyrussell&quot;+ ZSH_THEME=&quot;ys&quot; make the configuration file take effect 1source ~/.zshrc","link":"/Oh-my-zsh-Installation.html"},{"title":"Python-Variable-Name","text":"Get Python Variable Name Today when I was coding my programs about neuralnetwork, I met some problems about some variables’ value. And I tried to print them out like this. It was too verbose, and I started to think about whether the Python Standard Library support the operation of getting the string of variables’ name so that I can define a easy function like this to get variables’ (name, value) pair. 123456# return the string of variable's name ...def print_variable(variable): print(func(x), &quot;:&quot;, variable) So I Started to check the inspect lib which supports well for such operations. Inspect library’s often-used functions: Function Introduction getmembers(obj[, predicate]) Get a (k,v) tuple list of which the elements is object’s memberlist. And predicate can be used to filter the result like only getting the func object getmodule(obj) Get the module where the object is getfile(obj) Get the source file name where the object is getsource(obj) Get the source code of object isclass/isfunctino/ismethod judge the object’s type currentframe() Get the current stack frame object stack([context]) Get all the stack info by returning the tuple list of (frame, filename, line_number, function_name, code_context, index) Then My code is : 1234567891011import inspectdef get_variable_name(x): # Get the name of a variable as a string frame = inspect.currentframe() # Get the current stack frame while frame: if x in frame.f_locals.values(): # Get variables from locals() return [k for k,v in frame.f_locals.items() if v is x][0] if x in frame.f_globals.values(): # Get variables from globals() return [k for k,v in frame.f_globals.items() if v is x][0] frame = frame.f_back return None So then we get the method of getting variables’ name as a string. Then I can happily and easily get the status of some variables when code is running (as a lazy scape of debugging 😃 ) So define the function to print k-v pair easily 12def print_var_pair(x): print(get_variable_name(x), &quot;:&quot;, x) To conclude, the inspect lib is super powerful. It is a important part of python introspection mechanism, which help developer code and debug more flexibly.","link":"/Python-Variable-Name.html"},{"title":"STM32 Develop Environment on Kali","text":"以下是在Kali系统下搭建STM32编程环境的步骤： 安装编译工具链 在终端输入以下命令： 12sudo apt-get updatesudo apt-get install gcc-arm-none-eabi 安装st-link工具 在终端输入以下命令： 12345sudo apt-get install gitgit clone http://github.com/texane/stlink stlink.gitcd stlink.gitmake clean &amp;&amp; makesudo make install 下载安装openocd 在终端输入以下命令： 1sudo apt-get install openocd 安装STM32flash工具 在终端输入以下命令： 1sudo apt-get install STM32flash 在Kali系统中打开Arduino IDE 在终端输入以下命令： 1arduino 安装Arduino STM32库 在Arduino IDE中，选择“文件-首选项”，在“附加开发板管理器网址”中添加以下URL： 1https://github.com/STM32duino/BoardManagerFiles/raw/master/STM32/package_stm_index.json 但是在我本机下载的时候一直报错 json下载失败 ，在经过很久的寻找后，我终于在一个博客网站上找到替换性链接 1http://mcu.lvjianze.cn/study/STM32/package_stmicroelectronics_index.json 然后选择“工具-开发板-开发板管理器”，搜索“STM32”，然后安装“STM32 Cores”。 编写并编译代码 在Arduino IDE中，选择“文件-示例-STM32”来获取例子代码。然后编写你自己的代码，并尝试编译。 使用st-link烧录程序 将STM32开发板与计算机连接，然后在终端输入以下命令烧录程序： 1sudo openocd -f interface/stlink-v2.cfg -f target/STM32f1x.cfg -c &quot;program yourprogram.elf verify reset exit&quot; 以上就是在Kali系统下搭建STM32编程环境的步骤。","link":"/STM32-Develop-Environment-on-Kali.html"},{"title":"STM32 Learning Links","text":"Excellent Blog CSDN linux boy : 如何学习STM32 STM32之电源管理 嵌入式通信协议 STM32F103系列： STM32F103系列（一）：如何用DAP仿真器下载程序 STM32F103系列（二）：如何使用串口下载程序 STM32F103系列（三）：初识STM32F103 STM32F103系列（四）：寄存器 STM32F103系列（五）：寄存器版新建工程 STM32F103系列（六）：使用寄存器点亮LED STM32F103系列（七）：固件库函数雏形 STM32F103系列（八）：初识STM32标准库 STM32F103系列（九）：库函数版新建工程 STM32F103系列（十）：使用固件库点亮LED STM32F103系列（十一）：按键检测 STM32F103系列（十二）：GPIO位带操作 STM32F103系列（十三）：启动文件 STM32F103系列（十四）：RCC之使用HSE/HSI配置时钟 STM32F103系列（十五）：STM32中断应用概览","link":"/STM32-Learning-Links.html"},{"title":"STM32F407 Learning Note 1","text":"此学习笔记使用的开发板是 普中STMF407ZGT6, 学习资料下载地址为 普中科技 命名规则 以STM32F103RBT6这个型号为例子 STM32 F 103 R B T 6 STM32 STM32代表ARM Cortex-M内核的32位微控制器 F 芯片子系列 103 型号 R 引脚数 B 内嵌Flash容量 T 封装 6 工作温度范围 引脚数 T ———— 36脚 C ———— 48脚 R ———— 64脚 V ———— 100脚 Z ———— 144脚 I ———— 176脚 内嵌Flash容量 6 ———— 32K 8 ———— 64K B ———— 128K C ———— 256K D ———— 384K E ———— 512K G ———— 1M 封装 H ———— BGA封装 T ———— LQFP封装 U ———— VFQFPN封装 工作温度范围 6 ———— $-40-85 \\degree C$ 7 ———— $-40-105 \\degree C$ 详情参考图片 架构 总线矩阵 学习方法 基本外设 GPIO输入输出 外部中断 定时器 串口 基本外设接口 SPI IIC WDG (Watch Dog) ADC/DAC SDIO 高级功能 UCOS FATFS EMWIN 原则 由浅入深 由基础迈向困难 防止打击学习积极性","link":"/STM32F407-Learning-Note-1.html"},{"title":"STM32F407 Learning Note 2","text":"STM32最小系统组成 电源电路 复位电路 晶振电路 下载电路 理论上前三个就已经足够了，只是方便下载程序需要添加下载电路 STM32 启动模式 启动模式选择引脚 启动模式 说明 BOOT0 BOOT1 0 x 主闪存存储器 主闪存存储器作为启动区域 1 0 系统存储器 系统存储器作为启动区域 1 1 内置SRAM 内置SRAM被选为启动区域 串口下载的程序一般是通过第二种模式运行普中的串口下载端口已经设置好了引脚，可以一键下载 存储器映射 存储器本身不具有地址信息，它的地址(4GB)由芯片厂商或用户分配，给存储器分配地址的过程称为存储器映射，如果再分配一个地址就叫重映射。 序号 用途 地址范围 Block 0 SRAM(Flash) 0x0000 0000 ~ 0x1FFF FFFF(512MB) Block 1 SRAM 0x2000 0000 ~ 0x3FFF FFFF(512MB) Block 2 片上外设 0x4000 0000 ~ 0x5FFF FFFF(512MB) Block 3 FSMC的 bank1 ~ bank2 0x6000 0000 ~ 0x7FFF FFFF(512MB) Block 4 FSMC的 bank3 ~ bank4 0x8000 0000 ~ 0x9FFF FFFF(512MB) Block 5 FSMC Registers 0xA000 0000 ~ 0xBFFF FFFF(512MB) Block 6 Not Used 0xC000 0000 ~ 0xDFFF FFFF(512MB) Block 7 Cortex-M4 内部外设 0xE000 0000 ~ 0xFFFF FFFF(512MB) 详情请见 《STM32F407ZGT6数据手册.pdf》 寄存器及寄存器映射 通过给有特定功能的内存单元起一个别名，这个别名就是我们所说的寄存器。给已经分配好地址的有特定功能的内存单元起别名的过程就叫寄存器映射。 访问寄存器内容 总线地址 总线名称 总线基地址 相对外设基地址的偏移 APB1 0x4000 0000 0x0000 0000 APB2 0x4001 0000 0x0001 0000 AHB1 0x4002 0000 0x0002 0000 AHB2 0x5000 0000 0x1000 0000 AHB3 0x6000 0000 已不属于片上外设 端口外设地址 外设名称 外设基地址 相对于AHB1总线的地址偏移 GPIOA 0x4002 0000 0x0000 0000 GPIOB 0x4002 0400 0x0000 0400 GPIOC 0x4002 0800 0x0000 0800 GPIOD 0x4002 0C00 0x0000 0C00 GPIOE 0x4002 1000 0x0000 1000 GPIOF 0x4002 1400 0x0000 1400 GPIOG 0x4002 1800 0x0000 1800 GPIOH 0x4002 1C00 0x0000 1C00 GPIOF端口的寄存器地址 寄存器名称 寄存器地址 相对于GPIOF基地址的偏移 GPIO_MODER 0x4002 1400 0x00 GPIO_OTYPER 0x4002 1404 0x04 GPIO_OSPEEDR 0x4002 1408 0x08 GPIO_PUPDR 0x4002 140C 0x0C GPIO_IDR 0x4002 1410 0x10 GPIO_ODR 0x4002 1414 0x14 GPIO_BSRR 0x4002 1418 0x18 GPIO_LCKR 0x4002 141C 0x1C GPIO_AFRL 0x4002 1420 0x20 GPIO_AFRH 0x4002 1424 0x24 详情请见 《STM32F407ZGT6数据手册.pdf》 Set Register / Reset Register (GPIOx_BSRR) 置位寄存器 (Set Register) 置位寄存器（set register）用于将GPIO端口的某个或某些引脚置位，即将引脚的输出电平设置为高电平（1）。当写入一个1到该寄存器的相应位时，该引脚的输出电平就会变为高电平。 复位寄存器 (Reset Register) 复位寄存器（reset register）用于将GPIO端口的某个或某些引脚复位，即将引脚的输出电平设置为低电平（0）。当写入一个1到该寄存器的相应位时，该引脚的输出电平就会变为低电平。 区别 在操作上，置位寄存器和复位寄存器的区别在于其作用不同。置位寄存器将某个或某些引脚的输出电平设置为高电平，而复位寄存器则将某个或某些引脚的输出电平设置为低电平。在使用时，我们需要根据具体需求选择使用哪个寄存器来控制GPIO端口的引脚。","link":"/STM32F407-Learning-Note-2.html"},{"title":"STM32F407 Learning Note 3","text":"二极管在数字电路中的应用 Reprint : 二极管的所有基础知识点 早期的二极管 早期的二极管包含“猫须晶体”(Cat’s Whisker Crystals)和真空管(ThermionicValves)。 1904年，英国物理学家弗莱明根据“爱迪生效应”发明了世界上第一只电子二极管——真空电子二极管。它是依靠阴极热发射电子到阳极实现导通。 电源正负极接反则不能导电，它是一种能够单向传导电流的电子器件。早期电子二极管存在体积大、需预热、功耗大、易破碎等问题，促使了晶体二极管的发明。 晶体二极管 介绍 又称半导体二极管。1947年，美国人发明。在半导体二极管内部有一个PN结和两个引出端。 这种电子器件按照外加电压的方向，具备**单向电流的传导性**。现今最普遍的二极管大多是使用半导体材料如**硅**或**锗**。 结构 晶体二极管的核心是PN结 本征半导体：指不含任何掺杂元素的半导体，如纯硅晶片或纯锗晶片 P型半导体：掺杂了产生空穴的含较低电价杂质的半导体，如在本征半导体中Si(4+)中掺入Al(3+)的半导体 N型半导体：掺杂了产生电子的含较高电价杂质的半导体，如在本征半导体中硅Si(4+)中掺入磷P(5+)的半导体 由P型半导体和N型半导体相接触时，就产生一个独特的PN结界面，在界面的两侧形成空间电荷层，构成自建电场。 当外加电压等于零时，由于PN结两边载流子的浓度差引起扩散电流和由自建电场引起的漂移电流相等而处于电平衡状态，这也是常态下的PN结。 以PN结为核心结构，加上引线或引脚形成单向导电的二极管。 当外加电压方向由P极指向N极时，导通。 特性 二极管的伏安特性曲线如下： 外加电压Uw方向为P→N时，Uw大于起动电压，二极管导通； 外加电压Uw方向为N→P时，Uw大于反向击穿电压，二极管击穿。 性能参数 最大整流电流Idm：二极管连续工作允许通过的最大正向电流；电流过大，二极管会因过热烧毁；大电流整流可加装散热片。 最大反向电压Urm：Urm一般小于反向击穿电压，选规格以Urm为准，并留有余量；过电压易损坏二极管。 反向饱和电流Is：二极管外加反向电压时的电流值；Is反向击穿前很小，变化也很小；Is会随温度的升高而升高，一般地，常温下硅管Is&lt;1μA，锗管Is=30~300μA。 最高工作频率Fm：指二极管能保持良好工作特性的最高工作频率。 三极管在数字电路中的应用 Reprint : 三极管在数字电路中的应用 初步认识 三极管是一种常见的控制和驱动的器件 常用的三极管根据材料可以分为 硅管和锗管，两者原理相同，压降略有不同，前者用的比较普遍，而锗管应用较少，于是本文将使用硅管的参数进行阐述。三极管有两种类型：PNP型和NPN型，如下图， 三极管一共有三个极，从图来看，横向左侧的引脚叫做基极b(base)，中间有个箭头，一头连着基极，一头连着发射极e(emitter),最后一个引脚则是集电极c(collector)。 三极管的原理 三极管拥有三种工作模式：截至，放大，饱和 放大模式主要应用于模拟电路中，且用法和计算方法也比较复杂，我们暂时用不到。数字电路中主要使用的是三极管的开关特性，即只用到了截至和饱和两种状态。 用法特点： PNP: e极只要高于b极0.7V以上，e极和c极导通 NPN： b极只要高于e极0.7V以上，e极和c极导通 结论： 只要箭头的尾端高于箭头的头端0.7v即可接通e极和c极 饱和状态 条件： b极电流大于e极和c极之间的电流除以一个放大倍数$\\beta$ 对于放大倍数$\\beta$，对于常用的三极管打开可以认为是100， 这时候就要调整基极的阻流电阻来调整。 但是电阻值也不能太小，不然电流过大用以烧坏三极管 三极管的应用 三极管在数字电路里的开关特性，最常见的应用有两个：控制应用和驱动应用 控制： 图三中，三极管基极通过一个10K的电阻接到了单片机的一个IO口上，假定是P1.0,发射级直接接到5V的电源上，集电极接了一个LED小灯，并且串联了一个1K的限流电阻最终接到了电源负极GND上。如果P1.0由我们的程序给一个高电平1，那么基极b和发射极e都是5v，也就是说e到b不会产生一个0.7V的压降，这个时候发射极和集电极也就不会导通，那么这个电路在三极管处是断开的，没有电流通过，LED2小灯也不会亮。如果程序给P1.0一个低电平，这时e极还是5V，于是e和b之间产生了压差，三极管e和b之间也就导通了，三极管e和b之间大概有0.7V的压降，那么还有(5-0.7)V的电压会在电阻R47上。这个时候e和c之间也就导通了，那么LED小灯本身有2V的压降，三极管本身e和c之间大概有0.2V的压降，我们忽略不计。那么在R41上就会有大概3V的压降，可以计算出来。这条支路的电流大概是3mA,可以成功点亮LED灯 图4中，当IO口输出高电平为5V时，三极管导通，OUT输出低电平0V,当IO口输出低电平时，三极管截至，OUT则由上拉电阻R2的作用而输出12V的高电平，这样就实现了低电压控制高电压的工作原理 驱动 单片机的IO口可以输出一个高电平，但是它的输出电流却很有限，普通IO口输出高电平的时候，大概只有几十到几百uA的电流，达不到1mA，也就点不亮这个LED小灯或者是亮度很低，这个时候如果我们想用高电平点亮LED，就可以用上三极管来处理了，我们板上这种三极管型号可以通过500mA的电流，有的三极管通过的电流还更大一些，如图6所示，当IO口是高电平，三极管导通，因为三极管的电流放大作用，c极电流就可以达到mA以上了，就可以成功点亮LED小灯。","link":"/STM32F407-Learning-Note-3.html"},{"title":"STM32F407 Learning Note 4","text":"电容器在数字电路中的应用 Reprint : 单片机外围电路设计之二：电容 概念 电容(Capacitance) 亦称&quot;电容量&quot;,是指在给定电压下的电荷储存量，记为C，国际单位是法拉(F)。电容是表现电容器容纳电荷本领的物理量。电容器从物理学上讲，它是一种静态电荷储存介质，可能电荷会永久存在，这是它的特征，他的用途较广，主要用于电源滤波、信号滤波、信号耦合、谐振、滤波、补偿、充放电、储能、隔直流等电路中。 常见分类 结构 固定电容器 可变电容器 微调电容器 介质种类 有机介质电容器 无机介质电容器 电解电容器 空气介质电容器 用途 高频旁路 陶瓷电容器 云母电容器 玻璃膜电容器 涤纶电容器 玻璃釉电容器 低频旁路 纸质电容器 陶瓷电容器 铝电解电容器 涤纶电容器 滤波 调谐 高频耦合 低频耦合 小型电容器 电容作用 电容器基本的作用就是充电和放电，但是由于这种基本充放电作用所延伸出来的许多电路现象，使得电容器有着种种不容的用途。例如：在电子马达中，用它来产生相位；在照相闪光灯中，用它来产生高能量的瞬间放电等等。下面是电容器在电子电路中的一些作用： 类型 作用 耦合电容 用在耦合电路中的电容称为耦合电容，在阻容耦合放大器和其他电容耦合电路中大量使用这种电容电路，起隔直流通交流作用 滤波电容 用在滤波电路中的电容器称为滤波电容，在电源滤波和各种滤波器电路中使用这种电容电路，滤波电容将一定频段内的信号从总信号中去除 退耦电容 用在退耦电路中的电容器称为退耦电容，在多级放大器的直流电压供给电路中使用这种电容电路，退耦电容消除每级放大器之间的有害低频交连 高频消振电容 用在高频消振电路中的电容称为高频消振电容，在音频负反馈放大器中，为了消振可能出现的高频自激，采用这种电容电路，以消除放大器可能出现的高频啸叫 谐振电容 用在LC谐振电路中的电容器称为谐振电容，LC并联和串联谐振电路中都需这种电容电路 旁路电容 用在旁路电路中的电容器称为旁路电容，电路中如果需要从信号中去掉某一频段的信号，可以使用旁路电容电路，根据所去掉信号频率不同，有全频域（所有交流信号）旁路电容电路和高频旁路电容电路 中和电容 用在中和电路中的电容器称为中和电容。在收音机高频和中频放大器，电视机高频放大器中，采用这种中和电容电路，以消除自激 定时电容 用在定时电路中的电容器称为定时电容。在需要通过电容充电、放电进行时间控制的电路中使用定时电容电路，电容起控制时间常数大小的作用 积分电容 用在积分电路中的电容器称为积分电容。在电势场扫描的同步分离电路中，采用这种积分电容电路，可以从场复合同步信号中取出场同步信号 微分电容 用在微分电路中的电容器称为微分电容。在触发器电路中为了得到尖顶触发信号，采用这种微分电容电路，以从各类（主要是矩形脉冲）信号中得到尖顶脉冲触发信号 补偿电容 用在补偿电路中的电容器称为补偿电容，在卡座的低音补偿电路中，使用这种低频补偿电容电路，以提升放音信号中的低频信号，此外，还有高频补偿电容电路 自举电容 用在自举电路中的电容器称为自举电容，常用的OTL功率放大器输出级电路采用这种自举电容电路，以通过正反馈的方式少量提升信号的正半周幅度 分频电容 在分频电路中的电容器称为分频电容，在音箱的扬声器分频电路中，使用分频电容电路，以使高频扬声器工作在高频段，中频扬声器工作在中频段，低频扬声器工作在低频段","link":"/STM32F407-Learning-Note-4.html"},{"title":"STM32F407 Learning Note 5","text":"GPIO (General Purpose Input Output) GPIO (General Purpose Input Output) 是通用输入输出端口的简称，可以通过软件来控制其输入和输出。STM32芯片的GPIO引脚与外部设备连接起来，从而实现与外部通讯、控制以及数据采集的功能。 GPIO 功能描述 输入 输入浮空 输入上拉 输入下拉 模拟功能 输出 推挽输出(具有上拉或下拉功能) 该模式下，输出口连接到一个推挽输出的引脚。引脚在输出高电平时与电源连接，在输出低电平时与地连接。该模式下输出电流能力强，适合驱动电感、LED等负载 开漏输出(具有上拉或下拉功能) 该模式下，输出口连接到一个开漏输出的引脚。引脚在输出高电平时断开，输出低电平时与地连接。该模式下输出电流能力较弱，但适用于驱动一些需要共用信号线的设备，如I2C总线 复用功能推挽(具有上拉或下拉功能) 复用功能开漏(具有上拉或下拉功能) GPIO 初始化步骤 确定GPIO模式：输入、通用输出、复用功能还是模拟输入(MODER) 确定GPIO输出类型：推挽输出还是开楼输出(OTYPER) 配置输出的速度(OSPEEDR) 输出的时候内部的上\\下拉电阻要不要开启(PUPDR) 具体输出的内容(BSRR、ODR)","link":"/STM32F407-Learning-Note-5.html"},{"title":"STM32F407 Learning Note 6","text":"使用寄存器点亮LED灯 原理图 我们可以知道如果我们需要点亮LED的话需要设置PF9、PF10引脚产生低电平 流程 使用RCC_AHB1ENR寄存器对GPIOF端口的时钟使能 使用GPIOF_MODER寄存器配置GPIOF引脚的工作模式 使用GPIOF_BSRR寄存器设置或者清除GPIOF引脚的输出状态 代码 stm32f4xx.h123456789101112131415161718192021222324252627#ifndef STM32F4XX_H#define STM32F4XX_H// Base Address#define PERIPH_BASE ((unsigned int)0x40000000)#define AHB1PERIPH_BASE (PERIPH_BASE + 0x00020000)#define GPIOF_BASE (AHB1PERIPH_BASE + 0x1400)#define RCC_BASE (AHB1PERIPH_BASE + 0x3800)// RCC Register Address#define RCC_AHB1ENR *(unsigned int *)(RCC_BASE + 0x30)// Registers Address#define GPIOF_MODER *(unsigned int *)(GPIOF_BASE + 0x00)#define GPIOF_OTYPER *(unsigned int *)(GPIOF_BASE + 0x04)#define GPIOF_OSPEEDER *(unsigned int *)(GPIOF_BASE + 0x08)#define GPIOF_PUPDR *(unsigned int *) (GPIOF_BASE + 0x0C)#define GPIOF_IDR *(unsigned int *) (GPIOF_BASE + 0x10)#define GPIOF_ODR *(unsigned int *) (GPIOF_BASE + 0x14)#define GPIOF_BSRR *(unsigned int *) (GPIOF_BASE + 0x18)#define GPIOF_LCKR *(unsigned int *) (GPIOF_BASE + 0x1C)#define GPIOF_AFRL *(unsigned int *) (GPIOF_BASE + 0x20)#define GPIOF_AFRH *(unsigned int *) (GPIOF_BASE + 0x24)#endif main.c1234567891011121314151617181920212223242526#include &quot;stm32f4xx.h&quot;typedef unsigned int u32;void delay (u32 i);void delay (u32 i) { while (i--) ;}int main (void) { RCC_AHB1ENR |= 1&lt;&lt;5; GPIOF_MODER |= (1&lt;&lt;(2*9))|(1&lt;&lt;(2*10)); while (1) { GPIOF_BSRR = (1&lt;&lt;(16+9))|(1&lt;&lt;(10)); delay(0x1FFFF); GPIOF_BSRR = (1&lt;&lt;(9))|(1&lt;&lt;(16+10)); delay(0x1FFFF); }} 编译 &amp; 下载","link":"/STM32F407-Learning-Note-6.html"},{"title":"STM32F407 Learning Note 7","text":"STM32F4xx固件库 CMSIS标准 CMSIS标准(Cortex Microcontroller Software Interface Standard) 是 ARM Cortex 微控制器软件接口。 固件库介绍 Reprint : STM32F4xx固件库的说明及使用 文件夹内容 内容介绍 Libraries文件夹 CMSIS文件夹 存放的是符合CMSIS规范的一些文件。包括 STM32F4xx核内外设访问层代码,DSP 软件库,RTOS API,以及STM32F4xx片上外设访问层代码等。 STM32F4xx_StdPeriph_Driver文件夹 存放的是STM32F4xx标准外设固件库源码文件和对应的头文件。inc目录存放的是 stm32f4xx_ppp.h头文件,无需改动。src目录下面放的是stm32f4xx_ppp.c格式的固件库源码文件。每一个.c文件和一个相应的.h文件对应 Projects文件夹 由ST官方提供的固件实例源码 Utilities文件夹 官方评估板的一些对应源码 固件库说明 core_m4.h: CMSIS核心文件,提供进入M4内核接口由ARM公司提供,所有的CM4内核的芯片都适用 system_stm32f4xx.h: STM32F4片上外设访问层头文件,主要是系统寄存器定义申明以及包装内存操作 stm32f4xx_it.c,stm32f4xx_it.h, stm32f4xx_conf.h: 用来编写中断服务函数(中断服务函数也可以写在任意文件中) stm32f4xx_conf.h: 外设驱动配置文件 misc.c,misc.h,stm32f4xx_ppp.c,stm32f4xx_ppp.h 以及 stm32f4xx_rcc.c 和stm32f4xx_rcc.h: STM32F4xx标准的外设库文件。misc.c和misc.h是定义中断优先级分组和Systick定时器相关的函数stm32f3xx_rcc.c和stm32f4xx_rcc.h是与 RCC 相关的一些操作函数,作用主要是一些时钟的配置和使能。在任何一个 STM32 工程 RCC 相关的源文件和头文件是必须添加的。stm32f4xx_ppp.c和stm32f4xx_ppp.h是STM32F4xx标准外设固件库对应的源文件和头文件,包括一些常用外设 GPIO,ADC,USART 等 Application.c: 应用层代码 使用库函数点亮LED GPIO库函数介绍 GPIO外设的库文件 stm32f4xx_gpio.c stm32f4xx_gpio.h GPIO常用库函数 12345678910111213141516171819202122/* Function used to set the GPIO configuration to the default reset state ****/void GPIO_DeInit(GPIO_TypeDef* GPIOx);/* Initialization and Configuration functions *********************************/void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);/* GPIO Read and Write functions ***************************************** *****/uint8_t GPIO_ReadInputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);uint16_t GPIO_ReadInputData (GPIO_TypeDef* GPIOx);uint8_t GPIO_ReadOutputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);uint16_t GPIO_ReadOutputData (GPIO_TypeDef* GPIOx);void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);/* GPIO Alternate functions configuration function ****************************/void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF); 初始化函数 1void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct) 功能: 初始化一个或多个IO口(同一组端口)的工作模式、输出速度、输出类型、上下拉模式,即GPIO的4个配置寄存器。 初始化范例 12345678GPIO_InitTypeDef GPIO_InitStructure; // 定义结构体变量GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; // 输出模式GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; // 管脚设置F9GPIO_InitStructure.GPIO_Speed= GPIO_Speed_100MHz; //速度为100MHzGPIO_InitStructure.GPIO_OType = GPIO_OType_PP; // 推挽输出GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; // 上拉GPIO_Init(GPIOF, &amp;GPIO_InitStructure); // 初始化结构体 设置管脚输出电平函数 1void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 功能: 设置某个IO口为高电平(可同时设置同一端口的多个IO)。底层是通过配置BSRR寄存器。 1void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 功能: 设置某个IO口为低电平(可同时设置同一端口的多个IO)。底层是通过配置BSRR寄存器。 12void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal); 功能: 设置端口管脚输出电平,很少使用。 读取管脚输入电平函数 1uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 功能: 读取端口中的某个管脚输入电平。底层是通过读取IDR寄存器。 1uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx); 功能: 读取某组端口的输入电平。底层是通过读取IDR寄存器。 使能GPIO时钟函数 1RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState); 功能: 使能AHB1总线上的外设 使能范例1RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);","link":"/STM32F407-Learning-Note-7.html"},{"title":"STM32F407 Learning Note 8","text":"RCC 类型 系统复位 电源复位 备份域复位 系统复位 除了CSR(时钟控制寄存器)中的复位标志和备份域中的寄存器外，系统复位会将其他全部寄存器都复位为复位值。 产生原因： NRST引脚低电平 (外部复位) 窗口看门狗技术结束 (WWDG复位) 独立看门狗技术结束 (IWDG复位) 软件复位 (SW复位) 低功耗管理复位 软件复位 可通过查看 RCC_CSR(RCC时钟控制和状态寄存器) 中的复位标志确定 要对器件进行软件复位，必须将Cortex-M4F 应用中断和复位控制寄存器中的SYSRESETREQ位置1. 低功耗管理复位 两种引发方式: 进入待机模式时产生复位 进入停止模式时产生复位 时钟 可以使用三种不同的时钟源来驱动系统时钟(SYSCLK): HSI 振荡器时钟 HSE 振荡器时钟 主PLL 时钟 器件具有以下两种次级时钟源: LSI RC(32kHz 低速内部RC) 该RC用于驱动独立看门狗，也可选择提供给RTC用于停机/待机模式下的自动唤醒 LSE 晶振(32.768kHz 低速外部晶振) 该晶振用于驱动RTCCLK(RTC时钟) 对于每个时钟源来说，在未使用时都可以单独打开或者关闭，以降低功耗。","link":"/STM32F407-Learning-Note-8.html"},{"title":"STM32F407 Learning Note 9","text":"","link":"/STM32F407-Learning-Note-9.html"},{"title":"STM32F407 Learning Note","text":"目录 命名规则 架构 学习方法 STM32-启动模式 存储器映射 寄存器及寄存器映射 二极管在数字电路中的应用 三极管在数字电路中的应用 电容器在数字电路中的应用 GPIO (General Purpose Input Output) 使用寄存器点亮LED灯 STM32F4xx固件库 使用库函数点亮LED 使用库函数点亮LED 系统复位","link":"/STM32F407-Learning-Note.html"},{"title":"Upgarade the version of NodeJS","text":"The following operations is not helpful for Windows User. Steps: 1. Install the global manager n 1npm install -g n 2. Upgrade the version of node 12345678# if you want to upgrade to specified versionn &lt;version&gt; # e.g. n 10.0.0# install the latest versionn latest# install the latest stable versionn stable 3. Test 12$ node -vv19.9.0 4. Epilogue If you are Linux User, the former steps perfectly fits you, but if you are Windows User, you have to download the installation package specifically.","link":"/Upgarade-the-version-of-NodeJS.html"},{"title":"Upgrade Windows 10 to 11","text":"For inconvenience of Linux about playing games, I finally change my os from Kali Linux to Windows。 But since the version I installed is Windows 10 which is not supporting all the latest features, I had to upgrade my Windows to Windows 11. Steps: 1. Download Windows 11 Installation Assistant open Microsoft’s Installation Website download the assistant executable upgrade your OS and wait till the installation is over 2. Join the Windows Preview Experience Plan open the setting and click the “Upgrade and Security” click “Windows Preview Experience Plan” if your window shows blank resembling as follows: open “Windows Powershell (Admin)” and type 12345$path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\DataCollection&quot;# Telemetry level: 1 - basic, 3 - full$value = &quot;3&quot;New-ItemProperty -Path $path -Name AllowTelemetry -Value $value -Type Dword -ForceNew-ItemProperty -Path $path -Name MaxTelemetryAllowed -Value $value -Type Dword -Force reopen “Windows Preview Experience Plan” and you can see: and join the plan. 3. Upgrade the Windows open the setting of Windows Upgrade 4. Use it !","link":"/Upgrade-Windows-10-to-11.html"},{"title":"Xinput Configuration for Three-finger Touch","text":"Today we’ll stimulate the Win touchpad actions to configura my linux to enable tree-fingers touchpad operation with libinput-gesture Get the information of Touchpad 1$ xinput list 1$ xinput --list-props &quot;13&quot; Install the libinput-gesture Install the dependencies 1$ sudo apt install xdotool wmctrl Install the libinput-gesture 123$ git clone https://github.com/bulletmark/libinput-gestures.git$ cd libinput-gestures$ sudo ./libinput-gestures-setup install If you are happy with the default configuration, you could’t type the following: 1$ libinput-gesture autostart start Configuration The default gesture configurations are in /etc/libinput-gesture.conf, and if you want to create your own custom gestures the copy the file to ~/.config/libinput-gesture.conf and edit it. The followings are the available gestures: Gesture Example Mapping Swipe up KDE/GNOME move to the next workspace Swipe down KDE/GNOME move to the previous workspace Swipe left Swipe right Pinch in GNOME open/close overview Pinch out GNOME open/close overview Pinch clockwise Pinch anticlockwise Hold on You can choose to specify a specific finger count, typically 3 or more fingers for swipe or pinch.Gestures specified with finger count have priority over the same gesture specified without any finger count. configure Open the file 1$ vim /etc/libinput-gesture Edit the gesture you want, as for me I’ll add 3-fingers gestures to implement some operations. 12345678910# Switch to the Desktopgesture swipe down 3 xdotool key super+d# Swith the workspacegesture swipe left 4 xdotool key ctrl+alt+Rightgesture swipe right 4 xdotool key ctrl+alt+Left# Reduce or enlargegesture pinch in 2 xdotool key ctrl+miniusgesture pinch out 2 xdotool key ctrl+plus Relevant refrence Blog-陆道峰：kde5与archlinux环境下配置libinput-gestures多手势操作 Github: libinput-gesture Libinput: Gestures","link":"/Xinput-Configuration-for-Three-finger-Touch.html"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Sequential Tables","slug":"Sequential-Tables","link":"/tags/Sequential-Tables/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Assembler","slug":"Assembler","link":"/tags/Assembler/"},{"name":"Firmware","slug":"Firmware","link":"/tags/Firmware/"},{"name":"CMake","slug":"CMake","link":"/tags/CMake/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Render","slug":"Render","link":"/tags/Render/"},{"name":"Prettifly","slug":"Prettifly","link":"/tags/Prettifly/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Commands","slug":"Commands","link":"/tags/Commands/"},{"name":"NeuralNetwork","slug":"NeuralNetwork","link":"/tags/NeuralNetwork/"},{"name":"MNIST","slug":"MNIST","link":"/tags/MNIST/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"sudo","slug":"sudo","link":"/tags/sudo/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"Develop Environment","slug":"Develop-Environment","link":"/tags/Develop-Environment/"},{"name":"STM32F407","slug":"STM32F407","link":"/tags/STM32F407/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Touchpad","slug":"Touchpad","link":"/tags/Touchpad/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Assembler","slug":"Assembler","link":"/categories/Assembler/"},{"name":"Firmware","slug":"Firmware","link":"/categories/Firmware/"},{"name":"CMake","slug":"CMake","link":"/categories/CMake/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"Prettify","slug":"Hexo/Prettify","link":"/categories/Hexo/Prettify/"},{"name":"STM32","slug":"STM32","link":"/categories/STM32/"},{"name":"Commands","slug":"Linux/Commands","link":"/categories/Linux/Commands/"},{"name":"NeuralNetwork","slug":"Machine-Learning/NeuralNetwork","link":"/categories/Machine-Learning/NeuralNetwork/"},{"name":"Math Tokens","slug":"Markdown/Math-Tokens","link":"/categories/Markdown/Math-Tokens/"},{"name":"Shell","slug":"Linux/Shell","link":"/categories/Linux/Shell/"},{"name":"F407","slug":"STM32/F407","link":"/categories/STM32/F407/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Touchpad","slug":"Linux/Touchpad","link":"/categories/Linux/Touchpad/"},{"name":"upgrade 10 to 11","slug":"Windows/upgrade-10-to-11","link":"/categories/Windows/upgrade-10-to-11/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}