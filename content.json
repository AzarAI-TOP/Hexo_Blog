{"posts":[{"title":"Algorithm [0] Sequential Tables","text":"Structure: Sequential table is structure that store all the element in a continous space. In C Language, we could use structure type to define a sequential tables: 1234567#define Type inttypedef struct { Type * head; // used to store the pointer of the first element int size; // used to record the number of elements stored int capacity; // used to record the capacity of tables} Table; Usage: Init table: 1234567891011121314#define Defaul_Size 8void TableInit (Table* t) { t-&gt;head = (Type *)malloc(Default_Size * sizeof(Type)); // test if the space allocation is successful. if (!t-&gt;head) { printf(&quot;Error occurs while space allocation.&quot;); exit(1); } t-&gt;size = 0; t-&gt;capacity = Default_Size;} Add element: 12345678910111213int TableAdd (Table* t, Type e) { if (t-&gt;capacity &gt; t-&gt;size) { t-&gt;size++; t-&gt;head[t-&gt;size-1] = e; // succeed to delete element return 1; }else{ // failed to add element return 0; }} Delete element: 1234567891011121314int TableDel (Table* t, int index) { // test for the valid index if (t-&gt;size &amp;&amp; index&gt;=0 &amp;&amp; t-&gt;size&gt;index) { for (int i=index;i&lt;t-&gt;size-1;i++) t-&gt;head[i] = t-&gt;head[i+1]; t-&gt;size--; // succeed to delete element return 1; }else{ // failed to delete element return 0; }} Search element: 123456789int TableSearch (Table t, Type e) { // test for the valid index if (t.size) { for (int i=0;i&lt;t.size;i++) if(t.head[i]==e) return i; } // failed to delete element return -1; }} Free table: 123456789void TableFree (Table* t) { if (t-&gt;head != NULL) { free(t-&gt;head); t-&gt;head = NULL; } t-&gt;size = 0; t-&gt;capacity = 0;} Example: 1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &quot;sequentialTables.h&quot;int main (void) { Table t = {NULL, 0, 0}; // Init the table TableInit(&amp;t); // Add elements for (int i=0;i&lt;5;i++) TableAdd(&amp;t, i); // Show the table for (int i=0;i&lt;t.size;i++) printf(&quot;%d &quot;, t.head[i]); // Delete certain element TableDel(&amp;t, 3); for (int i=0;i&lt;t.size;i++) printf(&quot;%d &quot;, t.head[i]); // Search certain element index = TableSearch(t, 3); if (index&gt;0) printf(&quot;\\tGot it, index is %d\\n&quot;, index); else printf(&quot;\\tFailed to search.\\n&quot;); // Free the table TableFree(&amp;t); return 0;}","link":"/Algorithm-0-Sequential-Tables.html"},{"title":"Algorithm [1] Quick Sort","text":"了解快速排序算法: 快速排序是一种基于分治思想的排序算法.它选择一个基准元素,并将待排序序列分成两个子序列,一个小于基准元素的子序列和一个大于基准元素的子序列.然后递归地对这两个子序列进行排序,最终将整个序列排序完成. 快速排序的优势: 高效性: 平均时间复杂度为$O(nlogn)$ 最坏情况下的时间复杂度为 $O(n^2)$. 原地排序: 不需要额外的存储空间. 快速排序展示 动图展示 代码展示 递归法12345678910111213141516171819202122232425262728void swap(int *x, int *y) { int t = *x; *x = *y; *y = t;}void quick_sort_recursive(int arr[], int start, int end) { if (start &gt;= end) return; int mid = arr[end]; int left = start, right = end - 1; while (left &lt; right) { while (arr[left] &lt; mid &amp;&amp; left &lt; right) left++; while (arr[right] &gt;= mid &amp;&amp; left &lt; right) right--; swap(&amp;arr[left], &amp;arr[right]); } if (arr[left] &gt;= arr[end]) swap(&amp;arr[left], &amp;arr[end]); else left++; if (left) quick_sort_recursive(arr, start, left - 1); quick_sort_recursive(arr, left + 1, end);}void quick_sort(int arr[], int len) { quick_sort_recursive(arr, 0, len - 1);} 迭代法12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct _Range { int start, end;} Range;Range new_Range(int s, int e) { Range r; r.start = s; r.end = e; return r;}void swap(int *x, int *y) { int t = *x; *x = *y; *y = t;}void quick_sort(int arr[], const int len) { if (len &lt;= 0) return; // 避免len等於負值時引發段錯誤(Segment Fault) // r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素 Range r[len]; int p = 0; r[p++] = new_Range(0, len - 1); while (p) { Range range = r[--p]; if (range.start &gt;= range.end) continue; int mid = arr[(range.start + range.end) / 2]; // 選取中間點為基準點 int left = range.start, right = range.end; do { while (arr[left] &lt; mid) ++left; // 檢測基準點左側是否符合要求 while (arr[right] &gt; mid) --right; //檢測基準點右側是否符合要求 if (left &lt;= right) { swap(&amp;arr[left],&amp;arr[right]); left++;right--; // 移動指針以繼續 } } while (left &lt;= right); if (range.start &lt; right) r[p++] = new_Range(range.start, right); if (range.end &gt; left) r[p++] = new_Range(left, range.end); }} 快速排序在处理大规模数据时效果显著,但对于小规模数据可能不如其他简单排序算法. 在实现快速排序时,要注意处理边界情况和避免无限递归.","link":"/Algorithm-1-Quick-Sort.html"},{"title":"Anaconda Installation","text":"Introduction Anaconda is an open source, user-friendly and trusted Python distribution, which is the world’s preferred distribution for numerical and scientific computing. It contains more than 6,000 Python libraries to do with data visualization, ML, Deep Learning and data science. It provides a comprehensive and easy-to-use platform that includes a powerful package and environment management system. One of the key features of Anaconda is its package management system called “conda.” Conda allows users to easily install, update, and manage a wide range of packages and dependencies required for data analysis and scientific computing. It simplifies the process of setting up and maintaining a consistent working environment across different platforms. Anaconda also includes a collection of over 1,500 pre-built and optimized scientific packages and libraries.(which I like most! 😃) These packages cover various domains such as data manipulation, visualization, machine learning, and deep learning. Some of the popular packages included in Anaconda are NumPy, Pandas, Matplotlib, scikit-learn, and TensorFlow. In addition to package management, Anaconda provides a user-friendly integrated development environment (IDE) called Anaconda Navigator. The Navigator offers a graphical interface for managing environments, launching applications, and exploring available packages and documentation. It is particularly helpful for beginners who want to get started with data science without dealing with complex command-line tools. Anaconda supports multiple operating systems, including Windows, macOS, and Linux, making it accessible to a wide range of users. It is widely used by data scientists, researchers, and developers in academia, industry, and the open-source community. Overall, Anaconda is a comprehensive and versatile platform that simplifies the process of setting up and managing data science environments. It provides a rich ecosystem of packages and tools, making it an essential resource for anyone working in the field of data science and machine learning. Installation with Windows 1. Download the Anaconda installer original source Ali Disk for those who have no access to official website 2. Open the Anaconda installer Next I Agree Though “Just Me” option is recommended , but I’d like to choose “All Users” for the later convenience, so you can choose as your willingness. Type the path you want to install the Anaconda. I recommend to install the program in the different disk with System Disk (C:), for instance, Disk D is a really good option. Select both check boxes. Install 3. Check the installation Open the terminal press Win+R type “cmd” press Enter to open the terminal Open Python Interpreter type “python” in the terminal press Enter to run the command if your terminal becomes like the following picture, then your Anaconda environment installation has accomplished.","link":"/Anaconda-Installation.html"},{"title":"Assembler Jump Instructions","text":"1. Unconditional Jump 1jmp ;unconditinal jump 2. Jump according to CX,ECX registers 12jcxz ;jump if CX is 0jecxz ;jump if ECX is 0 3. Jump according to Flag bits Relavent PSW Flag bits 11 10 9 8 7 6 5 4 3 2 1 0 OF DF IF TF SF ZF - AF - PF - CF Overflow Direction Interrupt Trap Sign Zero - Assistance - Parity - Carry Jump according the PSW flags 12345678910111213141516jz ;jump if ZF flag is 1jnz ;jump if ZF flag is 0jc ;jump if CF flag is 1jnc ;jump if CF flag is 0jo ;jump if OF flag is 1jno ;jump if OF flag is 0js ;jump if SF flag is 1jns ;jump if SF flag is 0jp ;jump if PF flag is 1jnp ;jump if PF flag is 0jpe ;jump like JPjpo ;jump like JNP Jump according the comparision Equvalent12je ; == jump like JZjne ; != jump like JNZ Usigned Comparision1234567891011ja ; &gt;jna ; !&gt; (&lt;=)jae ; &gt;= jump like JNBjnae ; !&gt;= (&lt;) jump like JBjb ; &lt;jnb ; !&lt; (&gt;=)jbe ; &lt;= jump like JNAjnbe ; !&lt;= (&gt;) jump like JA Signed Comparision1234567891011jl ; &lt;jnl ; !&lt; (&gt;=)jle ; &lt;= jump like JNGjnle ; !&lt;= jump like JGjg ; &gt;jng ; !&gt; (&lt;=)jge ; &gt;= jump like JNLjnge ; !&gt;= (&lt;) jump like JL","link":"/Assembler-Jump-Instructions.html"},{"title":"Algorithm [2] Cycle List","text":"Instruction A cycle list is a linked list that has a cycle in it. A cycle is formed when a node in the end linked to the node in the start. With two pointer stored in each node, you can go throuth the cycle in both two directions easily and solve some circular problems. Code Completion Cycle_List.h123456789101112131415161718192021222324252627282930313233#ifndef _CYCLE_LIST_H#define _CYCLE_LIST_H#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;typedef struct Node{ int data; struct Node* prev; struct Node* next;} Node;typedef struct NodeHolder{ int size; struct Node* node;} NodeHolder;Node* Node_Init (int data);void Node_Connect_Prev (Node* nsrc, Node* ndest);void Node_Connect_Next (Node* nsrc, Node* ndest);NodeHolder* NodeHolder_Init (void);void NodeHolder_Init_Push (NodeHolder* nh, Node* node);void NodeHolder_Init_EndCycle (NodeHolder* nh);void NodeHolder_Insert_Prev (NodeHolder* nh, Node* node);void NodeHolder_Insert_Next (NodeHolder* nh, Node* node);void NodeHolder_Prev (NodeHolder* nh);void NodeHolder_Next (NodeHolder* nh);int NodeHolder_Pop (NodeHolder* nh);#endif Cycle_List.c123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#include &quot;Cycle_List.h&quot;Node* Node_Init (int data) { Node* pn = (Node*)malloc(sizeof(Node)); if (pn==NULL) { perror(&quot;[ERROR] Out of Memory&quot;); exit(EXIT_FAILURE); } pn-&gt;data = data; pn-&gt;prev = NULL; pn-&gt;prev = NULL; return pn;}void Node_Connect_Prev (Node* pnsrc, Node* pndest) { pnsrc-&gt;prev = pndest; pndest-&gt;next = pnsrc;}void Node_Connect_Next (Node* pnsrc, Node* pndest) { pnsrc-&gt;next = pndest; pndest-&gt;prev = pnsrc;}/** * When we create the cycle list, there are xxx steps: * 1. NodeHolder_Init : Create a blank holder * 2. NodeHolder_Init_Push : Push several nodes at the back of list * 3. NodeHolder_Init_EndCycle:Connect the head and tail of the list * In the second step, the holder holds the last node operated. * **/NodeHolder* NodeHolder_Init (void) { NodeHolder* pnh = (NodeHolder*)malloc(sizeof(NodeHolder)); if (pnh==NULL) { perror(&quot;[ERROR] Out of Memory&quot;); exit(EXIT_FAILURE); } pnh-&gt;size = 0; pnh-&gt;node = NULL; return pnh;}void NodeHolder_Init_Push (NodeHolder* pnh, Node* pnode) { if (pnh-&gt;node == NULL) { pnh-&gt;node = pnode; }else{ Node_Connect_Next(pnh-&gt;node, pnode); pnh-&gt;node = pnode; } pnh-&gt;size++;}void NodeHolder_Init_EndCycle (NodeHolder* pnh) { Node* head = pnh-&gt;node; Node* tail = pnh-&gt;node; while (head-&gt;prev != NULL) { head = head-&gt;prev; } Node_Connect_Next(tail, head); pnh-&gt;node = head;}void NodeHolder_Insert_Prev (NodeHolder* pnh, Node* pnode) { Node* current = pnh-&gt;node; Node* prev = pnh-&gt;node-&gt;prev; Node_Connect_Prev(current, pnode); Node_Connect_Prev(pnode, prev);}void NodeHolder_Insert_Next (NodeHolder* pnh, Node* pnode) { Node* current = pnh-&gt;node; Node* next = pnh-&gt;node-&gt;next; Node_Connect_Next(current, pnode); Node_Connect_Next(pnode, next);}void NodeHolder_Prev (NodeHolder* pnh) { pnh-&gt;node = pnh-&gt;node-&gt;prev;}void NodeHolder_Next (NodeHolder* pnh) { pnh-&gt;node = pnh-&gt;node-&gt;next;}int NodeHolder_Pop (NodeHolder* pnh) { int data = pnh-&gt;node-&gt;data; Node* prev = pnh-&gt;node-&gt;prev; Node* next = pnh-&gt;node-&gt;next; Node_Connect_Next(prev, next); free(pnh-&gt;node); pnh-&gt;node = next; pnh-&gt;size--; return data;} Preference Test a Linked List for Cyclicity","link":"/Algorithm-2-Cycle-List.html"},{"title":"Breadboard Usage","text":"本文转载自面包板使用简介 &lt;CSDN&gt; 面包板是实验室中用于搭接电路的重要工具,熟练掌握面包板的使用方法是提高实 验效率,减少实验故障出现几率的重要基础之一.下面就面包板的结构和使用方法做简单介绍. 面包板的外观和内部结构如图 1 所示,常见的最小单元面包板分上,中,下三部分, 上面和下面部分一般是由一行或两行的插孔构成的窄条,中间部分是由中间一条隔离凹 槽和上下各 5 行的插孔构成的宽条. 对上面和下面部分的窄条,外观和结构如图 2: 窄条上下两行之间电气不连通.每 5 个插孔为一组,通常的面包板上有 10 组或 11 组.对于 10 组的结构,左边 5 组内部电气连通,右边 5 组内部电气连通,但左右两边 之间不连通,这种结构通常称为 5-5 结构.还有一种 3-4-3 结构即左边 3 组内部电气连 通,中间 4 组内部电气连通,右边 3 组内部电气连通,但左边 3 组,中间 4 组以及右边 3 组之间是不连通的.对于 11 组的结构,左边 4 组内部电气连通,中间 3 组内部电气连 通,右边 4 组内部电气连通,但左边 4 组,中间 3 组以及右边 4 组之间是不连通的,这 种结构称为 4-3-4 结构. 中间部分宽条是由中间一条隔离凹槽和上下各 5 行的插孔构成.在同一列中的 5 个 插孔是互相连通的,列和列之间以及凹槽上下部分则是不连通的.外观及结构如图 3: 在做模拟电路实验的时候,通常是使用两窄一宽组成的小单元,同学们应按照实验指导教师的示范和要求,在宽条部分搭接电路的主体部分,上面的窄条取一行做电源, 下面的窄条取一行做接地.使用时注意窄条的中间部分不通. 在搭接数字电路时,有时由于电路的规模较大,需要多个宽条和窄条组成的较大的 面包板,但在使用时同样通常是两窄一宽同时使用,两个窄条的第一行一般和地线连接, 第二行和电源相连.由于集成块电源一般在上面,接地在下面,如此布局有助于将集成 块的电源脚和上面第二行窄条相连,接地脚和下面窄条的第一行相连,减少连线长度和跨接线的数量.中间宽条用于连接电路,由于凹槽上下是不连通的,所以集成块一般跨 插在凹槽上.具体参看图 4,5.","link":"/Breadboard-Usage.html"},{"title":"CMake[1] Basic Usage","text":"Environment Suppose we have the source files in the directory aim aim: \\ -- hello.c -- CMakeLists.txt The version I used in my CMake Learning series is ‘CMake 3.25.1’ Basic Usage For starters, let us consider the simplest CMakeLists file. To compile an executable from one source file, the CMakeLists file would contain two lines: project (Hello) add_executable (Hello Hello.c) project : indicate the name of the resulting workspace add_executable : add an executable target to the build process if your project requres several files ,it’s easy to modify with lines below. add_executable (Hello File1.c File2.c File3.c) Advanced a little bit Now, let’s consider the more complicated example below. cmake_minimum_required (3.0) project (HELLO) set (HELLO_SRCS File1.c File2.c File3.c) if (WIN32) set (HELLO_SRCS $(HELLO_SRCS) WinSupport.c) else () set (HELLO_SRCS $(HELLO_SRCS) UnixSupport.c) endif () # Look for the Tcl library find_library (TCL_LIBRARY NAMES tcl tcl84 tcl83 tcl82 tcl80 PATHS /opt/TclTk/lib c:/TclTk/lib ) if (TCL_LIBRARY) target_link_library (Hello ${TCL_LIBRARY}) endif () At first, Cmake will test the version of itself according to the cmake_minimum_required function. Then it will make all the source file a list and assign it to HELLO_SRCS. And, the conditional judgement will judge the type of the OS, and add the appropriate support file into the HELLO_SRCS. Finally, with the Tcl library assigned to TCL_LIBRARY, target_link_library will link the lib to the Hello executable target. Run the cmake 1.1 Running CMake’s Qt Interface Installation on Kali: $ sudo apt install cmake-qt-gui Run it : $ cmake-gui 1.2 Running the ccmake Curses Interface Installation on Kali: $ sudo apt install cmake-curses-gui Run it : $ ccmake ../cmake_test_1 make it : $ make","link":"/CMake-1-Basic-Usage.html"},{"title":"CMake[2] CMake Language","text":"Comment: # xxxxxx Basic Commands: project (projectname [C] [CXX] [Fortran] [NONE]) the top-level CMakeLists files should call the PROJECT command. This command both names the project and optionally specifies which languages will be used by it. set/unset the command manipulates variables and entries in the persistent cache. string, list, remove, sepatate_arguments the commands offer basic manipulation of strings and lists. add_executable, add_library the basic commands to define the executables and libraries to build and which files comprise them. target_link_libraries (&lt;target&gt; LINK_INTERFACES_LIBRARIES [[debug|optimized|general] &lt;lib&gt;]...) link the libs to the target. Flow Control: Conditional Statements : 12345if (FOO) if (FOO) # do something here # do something hereelse () or else (FOO) # do something else # do something elseendif () endif (FOO) condition operations include : Not AND OR EQUAL LESS GREATER STREQUAL STRLESS STRGREATER VERSION_EQUAL VERSION_LESS VERSION_GREATER Looping Constructs : foreach:123foreach (i ....) # do somethingendforeach (i) while:123while (CONDITION) # do somethingendwhile () Procedure Definitions : function: 123function (Func_name Func_Args) # do somethingendfunction () macro: 123macro (Macro_name Macro_Args) # do somethingendmacro () The main differences are that a macro does not push and pop a new variable scope, and that the arguments to a macro are not treated as variables but as strings replaced prior to execution. And the macro supports defining macros that take variable argument lists. The variable arguments can be referenced using ARGC (the number of arguments), ARGV (a list of all the arguments), ARGN (a list of all the arguments after the formal arguments). Interrupt Commands: break return","link":"/CMake-2-CMake-Language.html"},{"title":"CMake[3] Installing Files","text":"Software is typically installed into a directory sepatate from the source and build trees. This allows it ro be distributed in a clean form and isolates users from the details of the build process.CMake provides the install command to specify how a project is to be installed. usage: 1234567install(TARGETS MyLib EXPORT MyLibTargets LIBRARY DESTINATION lib # the destination path of dynamic-link library ARCHIVE DESTINATION lib # the destination path of static library RUNTIME DESTINATION bin # the destination path of executable PUBLIC_HEADER DESTINATION include # the destination path of header file ) The argument LIBRARY ARCHIVE RUNTIME PUBLIC_HEARDER is optional which can be chosen according to your needs. The path after DESTINATION is customizable, and the default parent path is set in CMAKE_INTSTALL_PREFIX, which can be changed by set command. The default value of CMAKE_INSTALL_PREFIX is: /usr/local on Unix-like system C:/Program Files/${PROJECT_NAME} The TARGETS keyword is immediately followed by a list of the targets created using add_executable and add_library commands. And targets files are categories as follows: RUNTIME executable dynamic-link library LIBRARY loadable modules shared libraries ARCHIVE import libraries static libraries Project may install files other than those are created with add_executable or add_library, such as hearder files or documentation. General-purpose installation of files is specified using the FILES signature: 123456install(FILES files ... DESTINATINO &lt;dir&gt; PERMISSION permissions... CONFIGURATIONS [Debug|Release|...] COMPONENT &lt;component&gt; RENAME &lt;name&gt;) The other similar signatures are PROGRAMS, DIRECTORY, SCRIPT and CODE.","link":"/CMake-3-Installing-Files.html"},{"title":"Change the Render of Hexo Markdown","text":"The article is translated from [Hexo]选择更高级的Markdown渲染器 by Xavier Jiezou from CSDN Introdeuction Since there are some problems of my default blog renderer – hexo-renderer-marked, like being not able to show html charactor &amp;emsp;, I decide to change the renderer to a better one – hexo-renderer-markdown-it. Installation uninstall hexo-renderer-marked 1npm un hexo-renderer-marked --save install hexo-renderer-marked 1npm i hexo-renderer-markdown-it --save If your npm gets stuck there, you can change your repository to accelarate it. install some plugins 123npm i hexo-checkboxnpm i hexo-imsizenpm i hexo-expandable other plugins are contained by hexo-renderer-markdown-it itself, and you shouldn’t install them manually. Configuration append the following text at the end of Hexo configuration file _config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142markdown: preset: &quot;default&quot; render: html: true xhtmlOut: false langPrefix: &quot;language-&quot; breaks: true linkify: true typographer: true quotes: &quot;&quot;&quot;''&quot; enable_rules: disable_rules: plugins: - markdown-it-abbr - markdown-it-cjk-breaks - markdown-it-deflist - markdown-it-emoji - markdown-it-footnote - markdown-it-ins - markdown-it-mark - markdown-it-sub - markdown-it-sup - markdown-it-checkbox - markdown-it-imsize - markdown-it-expandable - name: markdown-it-container options: success - name: markdown-it-container options: tips - name: markdown-it-container options: warning - name: markdown-it-container options: danger anchors: level: 2 collisionSuffix: &quot;&quot; permalink: false permalinkClass: &quot;header-anchor&quot; permalinkSide: &quot;left&quot; permalinkSymbol: &quot;¶&quot; case: 0 separator: &quot;-&quot; Usage Basic Name Description Syntax Example markdown-it-abbr Comment *[Name]: the name of someting *[Name]: the name of someting markdown-it-emoji Emoji :) 😃 markdown-it-footnote Footnote Reference literature[^1] Reference literature[^1] markdown-it-ins Underline ++underline++ underline markdown-it-mark Highlight ==Mark== Mark markdown-it-sub Sub Mark H~2~O H2O markdown-it-sup Sup Mark x^2^ x2 markdown-it-checkbox CheckBox unchecked: - [ ] checked: - [x] Unchecked Checked Advanced markdown-it-imsize : customize the size of an image format ![test](image.png =100x200) ouput &lt;p&gt;&lt;img src=&quot;image.png&quot; alt=&quot;test&quot; width=&quot;100&quot; height=&quot;200&quot;&gt;&lt;/p&gt; markdown-it-expandable : fold/unfold the content format 123+++ **Click to fold**The content to be hidden.+++ ouput &nbsp;Click to foldThe content to be hidden. markdown-it-container : customize the container format 12345678910111213141516171819::: tips**Tips**This is a tip.:::::: warning**Warning**This is a warning.:::::: danger**Danger**This is a danger warning.:::::: success**Success**This is a surccess container.::: output Tips This is a tip. Warning This is a warning. Danger This is a danger warning. Success This is a surccess container. addition you should add the following CSS content to the Style Configuration Files (e.g. ./node_modules/hexo-theme-icarus/source/css/default.styl). Otherwise, the backgroud color effect won’t work. 123456789101112131415161718192021222324.tips { padding-left: 10px; background-color rgba(52,152,219,.3); border-left 4px solid rgb(52,152,219); color: darken(rgb(52,152,219),20%);}.success { padding-left: 10px; background-color rgba(46,204,113,.3); border-left 4px solid rgb(46,204,113); color: darken(rgb(46,204,113),20%);}.warning { padding-left: 10px; background-color rgba(241,196,15,.3); border-left 4px solid rgb(241,196,15); color: darken(rgb(241,196,15),20%);}.danger { padding-left: 10px; background-color rgba(231,76,60,.3); border-left 4px solid rgb(231,76,60); color: darken(rgb(231,76,60),20%);}","link":"/Change-the-Render-of-Hexo-Markdown.html"},{"title":"Conver the image file to icon file","text":"With Python we can easily convert any image to icon file. 12345from PIL import Imageimg = Image.open(&quot;the path to your image&quot;)# icon_sizes = [(16, 16), (32, 32), (48, 48), (64, 64)]sizes = [(64, 64)]img.save(&quot;the destination path for icon file&quot;, sizes=sizes)","link":"/Conver-the-image-file-to-icon-file.html"},{"title":"Hexo Compress -- hexo-neat plugin","text":"Beacause of the bug of converting md to html, there are quite lots of verbose blank charactor in html files, which make Hexo Pages loading is quite slow, and the waiting is agonizing. So for more smooth use of Hexo. I decide to use hexo-neat plugin by rozbo to accelerate my blog load process. Preference 使用gulp精简hexo博客代码 Hexo-Neat介绍 Introduction of Hexo-Neat Author : rozbo Compress Method: Plugin Source neat-html HTMLMinifier neat-css clean-css neat-js UglifyJS Installation install the plugin in the root directory 1npm install hexo-neat --save append the neat configuration in the end of _config.yml 1234567891011121314151617181920212223neat_enable: true# compress htmlneat_html: enable: true exclude:# compress cssneat_css: enable: true exclude: - '**/*.min.css'# compress jsneat_js: enable: true mangle: true output: compress: exclude: - '**/*.min.js' - '**/jquery.fancybox.pack.js' - '**/index.js Test $ hexo clean &amp;&amp; hexo g","link":"/Hexo-Compress-hexo-neat-plugin.html"},{"title":"Install VSIX plugin of VS Code","text":"Reprint : VS Code 安装 VSIX 插件 There are diverse Extentions in the VS Code Marketplace and you can install them easily just by clicking Install button. But there are some plugins not released to Marketplace but packing to VSIX file. The following is several ways to install those plugins. Way 1 In the Extention, click the upper right corner, and click Install from VSIX. In the pop-up file selection interface, find the vsix file you want to install and click install to install. After the installation, the lower right corner will pop the notification of successful installation. Way 2 Press Ctrl+Shift+P Type install from … Choose Extentions: Install from VSIX Way 3 Open your Terminal Type code --install-extension xx.vsix Run the command 1Extension 'xxx.vsix' was successfully installed. Restart VSCode and you can see the plugin has been installed to Extensions.","link":"/Install-VSIX-plugin-of-VS-Code.html"},{"title":"Linux Commands : source","text":"Usage: 123source FileName# or. FileName Purpose: Read and run your commands in the FileName in the current bash environment. source is built-in commands of bash shell, and you could also execute it by dot “.” which run as source. Imagine such a scenario: you have a file named a.sh in which there is “export $Variable=1”, and you run it by ./a.sh. After that, you type echo $Variable, but there is nothing returned. But if you run the bash file by source, your command of echo gets 1. That’s because souce commands will run bash commands in the current bash environment, but ./a.sh will run your code in the sub-shell.","link":"/Linux-Commands-source.html"},{"title":"Linux Commands:sudo","text":"Usage 123456789101112131415161718192021222324252627282930313233343536373839404142434445sudo - execute a command as another userusage: sudo -h | -K | -k | -Vusage: sudo -v [-ABknS] [-g group] [-h host] [-p prompt] [-u user]usage: sudo -l [-ABknS] [-g group] [-h host] [-p prompt] [-U user] [-u user] [command]usage: sudo [-ABbEHknPS] [-r role] [-t type] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user] [VAR=value] [-i|-s] [&lt;command&gt;]usage: sudo -e [-ABknS] [-r role] [-t type] [-C num] [-D directory] [-g group] [-h host] [-p prompt] [-R directory] [-T timeout] [-u user] file ...Options: -A, --askpass use a helper program for password prompting -b, --background run command in the background -B, --bell ring bell when prompting -C, --close-from=num close all file descriptors &gt;= num -D, --chdir=directory change the working directory before running command -E, --preserve-env preserve user environment when running command --preserve-env=list preserve specific environment variables -e, --edit edit files instead of running a command -g, --group=group run command as the specified group name or ID -H, --set-home set HOME variable to target user's home dir -h, --help display help message and exit -h, --host=host run command on host (if supported by plugin) -i, --login run login shell as the target user; a command may also be specified -K, --remove-timestamp remove timestamp file completely -k, --reset-timestamp invalidate timestamp file -l, --list list user's privileges or check a specific command; use twice for longer format -n, --non-interactive non-interactive mode, no prompts are used -P, --preserve-groups preserve group vector instead of setting to target's -p, --prompt=prompt use the specified password prompt -R, --chroot=directory change the root directory before running command -r, --role=role create SELinux security context with specified role -S, --stdin read password from standard input -s, --shell run shell as the target user; a command may also be specified -t, --type=type create SELinux security context with specified type -T, --command-timeout=timeout terminate command after the specified time limit -U, --other-user=user in list mode, display privileges for user -u, --user=user run command (or edit file) as specified user name or ID -V, --version display version information and exit -v, --validate update user's timestamp without running a command -- stop processing command line arguments Purpose In Linux, typically only the root user is allowed to perform system-level tasks that require special privileges, such as installing software or modifying system settings. However, to make it convenient for other users to perform these tasks without switching to the root account, Linux provides the sudo command. The sudo command allows non-superusers to execute specified commands as the superuser, provided that they are authorized to use sudo in the sudoers file.By default, only system administrators or users with sudo privileges can modify the sudoers file. Therefore, only users who have been explicitly granted sudo access in the sudoers file can use the sudo command. User’s sudo access can be added or removed by editing the /etc/sudoers file or using the visudo command. In general, we use sudo to run a command as root user when the user authority required such as modify the files in /etc or etc.But It is agonizing to type password every time you use sudo command and you can skip the password asking process by configurating as follows: Method One: add your user into the sudo group # useradd -aG sudo &lt;username&gt; Method Two: add a line of following code at the end of the /etc/sudoers file &lt;username&gt; ALL=(ALL:ALL) NOPASSWD:ALL","link":"/Linux-Commands-sudo.html"},{"title":"Make Your Own Neuralnetwork","text":"In these days, I’ve read book named Make your own neuralnetwork by Tariq Rashid. The author use the vivid and simplest words to teach how to build a neuralnetwork with high-school-level math as well as a little bit knowledge of Martix. It’s interesting to build my own network and it runs well and the accuracy rate is quite high.The followings are the steps to build your own neuralnetwork and use it to recognize the MNIST dataset. 1. MNIST Database MNIST database is a large datset of handwritten digits that is commonly used for training and testing machine learning models. The dataset consists of 60,000 training images and 10,000 testing images, each of size 28 $\\times$ 28 pixels. The images are grayscale and show a single digit from 0 to 9. The following is pic: The following is the content of csv file; In the csv files, each training sample in a row consists of lable (first digit), and the greyscale of image (following 784 digits) 2. Build NeuralNetwork 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import numpy as npfrom scipy.special import expit as Sclass NeuralNetwork:# This neuralnetwork is initially designed as a input-hidden-output model def __init__(self, inputnodes, hiddennodes, outputnodes, learningrate) -&gt; None: # Ready the network configurations self.lr = learningrate self.inputnodes = inputnodes self.hiddennodes = hiddennodes self.outputnodes = outputnodes self.w_ih = np.random.normal(0.0, pow(self.hiddennodes, -0.5), (self.hiddennodes, self.inputnodes)) self.w_ho = np.random.normal(0.0, pow(self.hiddennodes, -0.5), (self.outputnodes, self.hiddennodes)) self.activation_func = S def train_single(self, input_list, target_list): # Train the neural-network with a given single data record inputs = np.array(input_list, ndmin=2).T targets = np.array(target_list, ndmin=2).T hidden_inputs = np.dot(self.w_ih, input_list) hidden_outputs = self.activation_func(hidden_inputs).reshape((100, 1)) final_inputs = np.dot(self.w_ho, hidden_outputs) final_outputs = self.activation_func(final_inputs).reshape((10, 1)) # Get the error data error_outputs = targets-final_outputs error_hidden = np.dot(self.w_ho.T, error_outputs) # Modify the weight bettween neuros self.w_ho += self.lr * np.dot((error_outputs * final_outputs * (1.0 - final_outputs)), np.transpose(hidden_outputs)) self.w_ih += self.lr * np.dot((error_hidden * hidden_outputs * (1.0 - hidden_outputs)), np.transpose(inputs)) def train(self, input_lists, target_lists, cycle=1, show_status:bool = False): for x in range(cycle): for i in range(len(target_lists)): self.train_single(data_train_value[i], data_train_target[i]) print(&quot;\\tTraining Prcessing: (cycle: &quot;, x+1, &quot;/&quot;, cycle, &quot;)&quot;) def query(self, input_list): inputs = np.array(input_list, ndmin=2).T inputs_hidden = np.dot(self.w_ih, inputs) outputs_hidden = self.activation_func(inputs_hidden) inputs_final = np.dot(self.w_ho, outputs_hidden) outputs_final = self.activation_func(inputs_final) return outputs_final After building a network, the following work is ready the data: by the way the structure of my project is : MyNeuralWork \\ -- main.py -- data \\ -- mnist_train.csv -- mnist_test.csv 123456789101112131415161718192021222324252627282930313233343536373839404142import pandas as pddef get_train_data(): # Version 1.0 # with open('./data/mnist_train.csv', 'r') as file: # data = file.readlines() # train_data = [] # target_data = [] # for image in data: # d = image.split(',') # train = np.asfarray(d[1:]) / 255.0 * 0.99 + 0.01 # train_data.append(train) # target = np.zeros(output_nodes) + 0.01 # target[int(d[0])] = 0.99 # target_data.append(target) # The Primary method of getting csv files is too ugly , I'd like to use pandas file_train = pd.read_csv('./data/mnist_train.csv', header=None, dtype='float').values # Normalize the data into the interval (0, 1) data_value = np.asfarray(file_train[:, 1:]) / 255.0 * 0.99 +0.01 data_target_pre = np.asfarray(file_train[:, 0]) data_target = [] for i in range(len(data_target_pre)): a = np.zeros(output_nodes) + 0.01 a[int(data_target_pre[i])] = 0.99 data_target.append(a) return data_target, data_valuedef get_test_data(): # File input method is same as done above. file_test = pd.read_csv('./data/mnist_test.csv', header=None, dtype='float').values # Normalize the data into the interval (0, 1) data_value = np.asfarray(file_test[:, 1:]) / 255.0 * 0.99 +0.01 data_target = np.asfarray(file_test[:, 0]) return data_target, data_value Now we get the function of getting train data and test data, let’s structure the whole code to finish MNIST training. 123456789101112131415161718192021222324252627282930313233# Configurate the date of networkinput_nodes = 784hidden_nodes = 100output_nodes = 10learning_rate = 0.3network = NeuralNetwork(input_nodes, hidden_nodes, output_nodes, learning_rate)# Get the MNIST datadata_train_target, data_train_value = get_train_data()data_test_target, data_test_value = get_test_data()# Data of model-trainingCYCLE = 20# Train the modelprint(&quot;Start training:&quot;)network.train(data_train_value, data_train_target, 20, show_status=True)print(&quot;\\tTraining is finisheed.&quot;)# Test the modelprint(&quot;Start testing:&quot;)correct = 0whole = len(data_test_target)for i in range(whole): answer_list = network.query(data_test_value[i]) answer = int(answer_list.argmax()) if data_test_target[i] == answer: correct += 1print('\\tTesting is finished.')print(&quot;The model accuracy rate is &quot;, correct / whole * 100, '%') Let’s run the code: 12345678910111213141516171819202122232425Start training: Training Prcessing: (cycle: 1 / 20 ) Training Prcessing: (cycle: 2 / 20 ) Training Prcessing: (cycle: 3 / 20 ) Training Prcessing: (cycle: 4 / 20 ) Training Prcessing: (cycle: 5 / 20 ) Training Prcessing: (cycle: 6 / 20 ) Training Prcessing: (cycle: 7 / 20 ) Training Prcessing: (cycle: 8 / 20 ) Training Prcessing: (cycle: 9 / 20 ) Training Prcessing: (cycle: 10 / 20 ) Training Prcessing: (cycle: 11 / 20 ) Training Prcessing: (cycle: 12 / 20 ) Training Prcessing: (cycle: 13 / 20 ) Training Prcessing: (cycle: 14 / 20 ) Training Prcessing: (cycle: 15 / 20 ) Training Prcessing: (cycle: 16 / 20 ) Training Prcessing: (cycle: 17 / 20 ) Training Prcessing: (cycle: 18 / 20 ) Training Prcessing: (cycle: 19 / 20 ) Training Prcessing: (cycle: 20 / 20 ) Training is finisheed.Start testing: Testing is finished.The model accuracy rate is 94.06 % we can see the accuracy rate is up to 94%, it’s really amazing for me (a green hand for Deeplearning).","link":"/Make-Your-Own-Neuralnetwork.html"},{"title":"Markdown Math Tokens","text":"Frequently Used Symbols: Name Code Render Effect Infinity \\infty or \\infini $\\infty$ Empty Set \\empsey or \\varnothing $\\emptyset$or$\\varnothing$ In \\in or \\ni $\\in$ or $\\ni$ Not In \\notin $\\notin$ Subset \\subseteq $\\subseteq$ Subset But Not Equal \\subsetneqq $\\subsetneqq$ Superset \\supset $\\supseteq$ Superset But Not Equal \\supsetneqq $\\supsetneqq$ Intersection \\cap $\\cap$ Union \\cup $\\cup$ Equal = $=$ Not Equal \\neq or \\not = $\\neq$ or $\\not =$ Greater Than \\geq or \\geqq or \\geqslant $\\geq$ or $\\geqq$ or $\\geqslant$ Less Than \\leq or \\leqq or \\leqslant $\\leq$ or $\\leqq$ or $\\leqslant$ Not \\neg $\\neg$ And \\land $\\land$ Or \\lor $\\lor$ Exisit \\exists $\\exists$ Exisit Only One \\exists! $\\exists!$ For All \\forall $\\forall$ Derive \\Rightarrow or \\Longrightarrow $\\Rightarrow$ or $\\Longrightarrow$ Be Derived \\Leftarrow or \\Longleftarrow $\\Leftarrow$ or $\\Longleftarrow$ Vector \\vec{v} or \\overrightarrow{v} $\\vec{v}$ or $\\overrightarrow{v}$ Perpendicular \\perp $\\perp$ Not Perpendicular \\not\\perp $\\not\\perp$ Parallel \\parallel $\\parallel$ Not Parallel \\nparallel $\\nparallel$ Similar \\sim $\\sim$ Congruence \\cong $\\cong$ Angle \\angle $\\angle$ Triangle \\triangle or \\triangledown \\triangleright or \\triangleleft $\\triangle$ or $\\triangledown$ $\\triangleright$ or $\\triangleleft$ Plus Minus \\pm $\\pm$ Minus Plus \\mp $\\mp$ Multiply \\times $\\times$ Divide \\div $\\div$ Dot Product \\cdot $\\cdot$ Ellipsis \\cdots $\\cdots$ Fraction \\frac{a}{b} or \\dfrac{a}{b} $\\frac{a}{b}$ or $\\dfrac{a}{b}$ Root \\sqrt[n]{x} $\\sqrt[n]{x}$ Integral \\int_{a}^{b} $\\int_{a}^{b}$ Limit \\lim\\limits_{x \\rightarrow \\infty}a $\\lim\\limits_{x \\rightarrow \\infty}a$ Add \\sum_{i=0}^{n}a $\\sum_{i=0}^{n}a$ Product \\prod_{i=0}^{n}a $\\prod_{i=0}^{n}a$ Logarithm \\log_{n}a or \\ln or \\lg $\\log_{n}a$ or $\\ln$ or $\\lg$ Trignometric Function \\sin or \\sec or \\tan \\cos or \\csc or \\cot $\\sin$ or $\\sec$ or $\\tan$ $\\cos$ or $\\csc$ or $\\cot$ Because \\because $\\because$ Therefore \\therefore $\\therefore$ Overline \\overline{a+b+c} $\\overline{a+b+c}$ Underline \\underline{a+b+c} $\\underline{a+b+c}$ Upper Bracket \\overbrace{a+ \\cdots +a}^{x} $\\overbrace{a+ \\cdots +a}^{x}$ Under Bracket \\underbrace{a+ \\cdots +a}_{x} $\\underbrace{a+ \\cdots +a}_{x}$ Tokens \\hat{x} or \\check{x} or \\breve{x} $\\hat{x}$ or $\\check{x}$ or $\\breve{x}$ Space &amp;emsp; or &amp;ensp; or &amp;nbsp; x x Equivalent \\equiv $\\equiv$","link":"/Markdown-Math-Tokens.html"},{"title":"NodeJS Mirror Source","text":"To change Node.js mirror/source, you can follow these steps: Open a terminal or command prompt. Use the following command to set the registry to your preferred mirror/source: 1npm config set registry [mirror/source URL] For example, if you want to use the mirror/source provided by Taobao, you can run: 1npm config set registry https://registry.npm.taobao.org (Optional) Back to the official source: 1npm config set registry https://registry.npmjs.org/ Verify the configuration by running: 1npm config get registry This should output the URL of the mirror/source you just set. That’s it! Now Node.js and npm will use your preferred mirror/source for package installation and updates.","link":"/NodeJS-Mirror-Source.html"},{"title":"Oh-my-zsh Installation","text":"Oh My Zsh is a delightful, open source, community-driven framework for managing your Zsh configuration. It comes bundled with thousands of helpful functions, helpers, plugins, themes, and a few things that make you shout… \"Oh My ZSH!\" What is Oh My Zsh? Oh My Zsh is an open source, community-driven framework for managing your Zsh configuration. Sounds boring. Let’s try again. Oh My Zsh will not make you a 10x developer…but you may feel like one! Once installed, your terminal shell will become the talk of the town or your money back! With each keystroke in your command prompt, you’ll take advantage of the hundreds of powerful plugins and beautiful themes. Strangers will come up to you in cafés and ask you, “that is amazing! are you some sort of genius?” Finally, you’ll begin to get the sort of attention that you have always felt you deserved. …or maybe you’ll use the time that you’re saving to start flossing more often. 😬 How to install oh-my-zsh 1. Install zsh shell 123$ sudo apt install zsh# change the default shell to zsh$ chsh -s /bin/zsh &lt;username&gt; 2. Install oh-my-zsh 123456# get the installation shell scriptswget https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh# change the executable permissionchmod +x install.sh# run it./install.sh 3. Configurate ZSH install the plugins zsh-syntax-highlighting 1git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting if your web is blocked for github.com you can use 1git clone https://gitee.com/zjy_1671/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting zsh-autosuggestions 1git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions if your web is blocked for github.com you can use 1git clone https://gitee.com/yu_flute/zsh-autosuggestions.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions configurate .zshrc open the configuration file 1vim ~/.zshrc enable the zshconfig command .zshrc1alias zshconfig=&quot;vim ~/.zshrc&quot; change the content .zshrc1234567- plug=(git)+ plug=(+ git+ sudo+ zsh-syntax-highlighting+ zsh-autosuggestions+ ) change the theme .zshrc12- ZSH_THEME=&quot;robbyrussell&quot;+ ZSH_THEME=&quot;ys&quot; make the configuration file take effect 1source ~/.zshrc","link":"/Oh-my-zsh-Installation.html"},{"title":"Python-Variable-Name","text":"Get Python Variable Name Today when I was coding my programs about neuralnetwork, I met some problems about some variables’ value. And I tried to print them out like this. It was too verbose, and I started to think about whether the Python Standard Library support the operation of getting the string of variables’ name so that I can define a easy function like this to get variables’ (name, value) pair. 123456# return the string of variable's name ...def print_variable(variable): print(func(x), &quot;:&quot;, variable) So I Started to check the inspect lib which supports well for such operations. Inspect library’s often-used functions: Function Introduction getmembers(obj[, predicate]) Get a (k,v) tuple list of which the elements is object’s memberlist. And predicate can be used to filter the result like only getting the func object getmodule(obj) Get the module where the object is getfile(obj) Get the source file name where the object is getsource(obj) Get the source code of object isclass/isfunctino/ismethod judge the object’s type currentframe() Get the current stack frame object stack([context]) Get all the stack info by returning the tuple list of (frame, filename, line_number, function_name, code_context, index) Then My code is : 1234567891011import inspectdef get_variable_name(x): # Get the name of a variable as a string frame = inspect.currentframe() # Get the current stack frame while frame: if x in frame.f_locals.values(): # Get variables from locals() return [k for k,v in frame.f_locals.items() if v is x][0] if x in frame.f_globals.values(): # Get variables from globals() return [k for k,v in frame.f_globals.items() if v is x][0] frame = frame.f_back return None So then we get the method of getting variables’ name as a string. Then I can happily and easily get the status of some variables when code is running (as a lazy scape of debugging 😃 ) So define the function to print k-v pair easily 12def print_var_pair(x): print(get_variable_name(x), &quot;:&quot;, x) To conclude, the inspect lib is super powerful. It is a important part of python introspection mechanism, which help developer code and debug more flexibly.","link":"/Python-Variable-Name.html"},{"title":"STM32 Develop Environment on Kali","text":"以下是在Kali系统下搭建STM32编程环境的步骤: 安装编译工具链 在终端输入以下命令: 12sudo apt-get updatesudo apt-get install gcc-arm-none-eabi 安装st-link工具 在终端输入以下命令: 12345sudo apt-get install gitgit clone http://github.com/texane/stlink stlink.gitcd stlink.gitmake clean &amp;&amp; makesudo make install 下载安装openocd 在终端输入以下命令: 1sudo apt-get install openocd 安装STM32flash工具 在终端输入以下命令: 1sudo apt-get install STM32flash 在Kali系统中打开Arduino IDE 在终端输入以下命令: 1arduino 安装Arduino STM32库 在Arduino IDE中,选择&quot;文件-首选项&quot;,在&quot;附加开发板管理器网址&quot;中添加以下URL: 1https://github.com/STM32duino/BoardManagerFiles/raw/master/STM32/package_stm_index.json 但是在我本机下载的时候一直报错 json下载失败 ,在经过很久的寻找后,我终于在一个博客网站上找到替换性链接 1http://mcu.lvjianze.cn/study/STM32/package_stmicroelectronics_index.json 然后选择&quot;工具-开发板-开发板管理器&quot;,搜索&quot;STM32&quot;,然后安装&quot;STM32 Cores&quot;. 编写并编译代码 在Arduino IDE中,选择&quot;文件-示例-STM32&quot;来获取例子代码.然后编写你自己的代码,并尝试编译. 使用st-link烧录程序 将STM32开发板与计算机连接,然后在终端输入以下命令烧录程序: 1sudo openocd -f interface/stlink-v2.cfg -f target/STM32f1x.cfg -c &quot;program yourprogram.elf verify reset exit&quot; 以上就是在Kali系统下搭建STM32编程环境的步骤.","link":"/STM32-Develop-Environment-on-Kali.html"},{"title":"STM32 Learning Links","text":"Excellent Blog CSDN linux boy : 如何学习STM32 STM32之电源管理 嵌入式通信协议 STM32F103系列: STM32F103系列(一):如何用DAP仿真器下载程序 STM32F103系列(二):如何使用串口下载程序 STM32F103系列(三):初识STM32F103 STM32F103系列(四):寄存器 STM32F103系列(五):寄存器版新建工程 STM32F103系列(六):使用寄存器点亮LED STM32F103系列(七):固件库函数雏形 STM32F103系列(八):初识STM32标准库 STM32F103系列(九):库函数版新建工程 STM32F103系列(十):使用固件库点亮LED STM32F103系列(十一):按键检测 STM32F103系列(十二):GPIO位带操作 STM32F103系列(十三):启动文件 STM32F103系列(十四):RCC之使用HSE/HSI配置时钟 STM32F103系列(十五):STM32中断应用概览","link":"/STM32-Learning-Links.html"},{"title":"STM32F407 Learning Note 1","text":"命名规则 以STM32F103RBT6这个型号为例子 STM32 F 103 R B T 6 STM32 STM32代表ARM Cortex-M内核的32位微控制器 F 芯片子系列 103 型号 R 引脚数 B 内嵌Flash容量 T 封装 6 工作温度范围 引脚数 T ———— 36脚 C ———— 48脚 R ———— 64脚 V ———— 100脚 Z ———— 144脚 I ———— 176脚 内嵌Flash容量 6 ———— 32K 8 ———— 64K B ———— 128K C ———— 256K D ———— 384K E ———— 512K G ———— 1M 封装 H ———— BGA封装 T ———— LQFP封装 U ———— VFQFPN封装 工作温度范围 6 ———— $-40-85 \\degree C$ 7 ———— $-40-105 \\degree C$ 详情参考图片 架构 总线矩阵 学习方法 基本外设 GPIO输入输出 外部中断 定时器 串口 基本外设接口 SPI IIC WDG (Watch Dog) ADC/DAC SDIO 高级功能 UCOS FATFS EMWIN 原则 由浅入深 由基础迈向困难 防止打击学习积极性","link":"/STM32F407-Learning-Note-1.html"},{"title":"STM32F407 Learning Note 10","text":"SysTick系统定时器 SysTick定时器介绍 SysTick定时器也叫做SysTick滴答定时器,它是Cortex-M4内核的一个外设,被嵌入在NVIC中.它是一个24位向下递减的定时器,每计数一次所需的时间是$\\frac{1}{SYSTICK}$,SYSTICK是系统定时器时钟,它可以直接取自系统时钟,还可以通过系统时钟8分频后获取,当定时器计数到0时,将LOAD寄存器中自动重装定时器初值,重新向下递减计数,如此循环往复.如果开启SysTick中断的话,当定时器计数到0,将产生一个中断信号.因此只要知道计数的次数就可以准确得到它延时的时间. CTRL寄存器 CTRL是SysTick定时器的控制及状态寄存器. 位段 名称 类型 复位值 描述 0 ENABLE R/W 0 SysTick定时器使能位 1 TICKINT R/W 0 1=SysTick倒数到0时产生SysTick异常请求0=SysTick倒数到0时无动作 2 CLKSOURCE R/W 0 1=外部时钟源(STCLK)0=内核时钟(FCLK) 16 COUNTFLAG R 0 如果在上次读取本寄存器后,SysTick已经数到0,则该位为1,如果读取该位,该位将自动清零 LOAD寄存器 LOAD是SysTick定时器的重装载数值寄存器. 位段 名称 类型 复位值 描述 23:0 RELOAD R/W 0 当倒数至零时,将被重装载的值 VAL寄存器 VAL是SysTick定时器的当前数值寄存器. 位段 名称 类型 复位值 描述 23:0 CURRENT R/Wc 0 读取时返回当前倒计时的值,写他则使之清零,同时还会清除在CTRL(SysTick控制及状态寄存器)中的COUNTFLAG标志 SysTick定时器配置步骤 设置SysTick定时器的时钟源 设置SysTick定时器的重装初始值 (Optional)使能SysTick中断 清零SysTick定时器当时计数器的值 打开SysTick定时器 SysTick延时程序代码演示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657void SysTick_Init (u8 SYSCLK) { SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); // SYSCLK的8分频 保存1us所需的计数次数 fac_us = SYSCLK/8; // 保存1ms需要的SysTick时钟数 fac_ms = (u16)fac_us*1000;}void delay_us (u32 nus) { // 配置寄存器 SysTick-&gt;LOAD = nus*fac_us; SysTick-&gt;VAL = 0x00; SysTick-&gt;CTRL |= 0x01; // 开始延时 u32 tmp; do { tmp = SysTick-&gt;CTRL; }while ((tmp&amp;0x01)&amp;&amp;!(tmp&amp;(1&lt;&lt;16))); // 关闭寄存器 SysTick-&gt;CTRL &amp;= ~0x01; SysTick-&gt;VAL = 0x00;}void delay_nms (u32 nms) { // 配置寄存器 SysTick-&gt;LOAD = (u32)nms*fac_ms; SysTick-&gt;VAL = 0x00; SysTick-&gt;CTRL |= 0x01; // 开始延时 u32 tmp; do { tmp = SysTick-&gt;CTRL; }while ((tmp&amp;0x01)&amp;&amp;!(tmp&amp;(1&lt;&lt;16))); // 关闭寄存器 SysTick-&gt;CTRL &amp;= ~0x01; SysTick-&gt;VAL = 0x00;}/* * 但是delay_nms最高延时只能 798ms (2^24/21),为了延长,所以要写其他另一个函数进行长时间的延时. */void delay_ms (u16 nms) { // 考虑到有些用户可能会超频使用 // 比如超频到248MHz时,最大单次延时为541ms u8 repeat = nms/540; u16 remain = nms%540; while (repeat--) delay_nms(540); if (remain) delay_nms(remain);}","link":"/STM32F407-Learning-Note-10.html"},{"title":"STM32F407 Learning Note 11","text":"蜂鸣器介绍 蜂鸣器是一种一体化结构的电子讯响器,采用直流电压供电,广泛应用于各领域各种电子产品中作发声器件. 分类 压电式蜂鸣器 主要由多谐振荡器,压电蜂鸣片,阻抗匹配器,共鸣箱及外壳等组成.当接通电源后(1.515V直流工作电压),多谐振荡器起振,输出1.55kHz的音频信号,阻抗匹配器推动压电蜂鸣片发声. 电磁式蜂鸣器 主要由振荡器,电磁线圈,磁铁,振动膜片及外壳组成.接通电源后,振荡器产生的音频信号电流通过电磁线圈,使电磁线圈产生磁场,振动膜片在电磁线圈和磁铁的相互作用下,周期性的振动发声. 参数以及更改方式 音色 ———— 更改波形 音调 ———— 更改频率 音量 ———— 更改占空比 蜂鸣器模块电路 蜂鸣器代码实现 beep.h12345678910111213141516#ifndef _BEEP_H#define _BEEP_H#include &quot;stm32f4xx.h&quot;#include &quot;band.h&quot;#define Beep_Pin GPIO_Pin_8#define Beep_Port GPIOF#define Beep PFout(8)void BEEP_Init (void);void BEEP_On (void);void BEEP_Off (void);void BEEP_Toggle (void);#endif beep.h1234567891011121314151617181920212223242526272829#include &quot;beep.h&quot;void BEEP_Init (void) { GPIO_InitTypeDef GPIO_InitStructure; // Define the structure variable RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; // Configurate GPIO Mode GPIO_InitStructure.GPIO_Pin = Beep_Pin; // Set the pinouts GPIO_InitStructure.GPIO_Speed= GPIO_Speed_100MHz; //Set the speed to 100MHz GPIO_InitStructure.GPIO_OType = GPIO_OType_PP; // Set the output type GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; // Pull up GPIO_Init(Beep_Port, &amp;GPIO_InitStructure); // Initialize the structure GPIO_ResetBits(Beep_Port, Beep_Pin);}void BEEP_On (void) { Beep = 1;}void BEEP_Off (void) { Beep = 0;}void BEEP_Toggle (void) { Beep = !Beep;}","link":"/STM32F407-Learning-Note-11.html"},{"title":"STM32F407 Learning Note 12","text":"按键介绍 按键是一种电子开关,使用时亲亲按开关就可以使开关接通,当松开手时,开关断开. (pcb按钮有四个引脚,但是有两两短路连接的,也就是说在电气属性方面相当于两个引脚.pcb按钮之所以要做成4个引脚是为了将按钮焊紧在pcb板上,按动时候就不会摇晃,如果是两个引脚,在按动的时候引脚容易出现晃动的现象,甚至引脚断开,音响按钮功能.) 机械弹性开关的电压信号图 信号噪音抖动 由于机械点的弹性作用,按键开关在闭合时不会马上稳定额接通,在断开时也不会一下子断开,因而在闭合和断开的瞬间均伴随着一连串的抖动.抖动时间的长短由按键的机械特性决定,一般为 5ms 到 10ms.按键稳定闭合时间则是由操作人员决定的,一般为零点几秒至数秒.按键抖动会引起按键被误读多次.为了确保cPU对按键的一次闭合仅作一次处理,必须进行消抖.消抖则是有两种方式: 硬件消抖 (硬件较少) RS触发器 电容滤波 软件消抖 (硬件较多) 一般来说,一个简单的按键就是先读取按键的状态,如果得到按键按下之后,延时10ms,再次读取按键状态,如果按键还是处于按下状态,那么说明按键已经按下. 为了电路更加简单,一般采用软件消抖.我们开发板也是采用软件消抖 程序流程 使能按键端口 按键检测 主函数控制 代码实现 key.h12345678910111213141516171819#ifndef _KEY_H#define _KEY_H#include &quot;stm32f4xx.h&quot;#include &quot;band.h&quot;#define KEY_Port GPIOE#define KEY_1_Pin GPIO_Pin_2#define KEY_2_Pin GPIO_Pin_3#define KEY_3_Pin GPIO_Pin_4#define Key1 PEin(2)#define Key2 PEin(3)#define Key3 PEin(4)void KEY_Init (void);#endif key.c123456789101112131415#include &quot;key.h&quot;void KEY_Init (void) { GPIO_InitTypeDef GPIO_InitStructure; // Define the structure variable RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE); GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN; // Configurate GPIO Mode GPIO_InitStructure.GPIO_Pin = KEY_1_Pin|KEY_2_Pin|KEY_3_Pin; // Set the pinouts GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; // Pull up GPIO_Init(KEY_Port, &amp;GPIO_InitStructure); // Initialize the structure} main.c123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &quot;stm32f4xx.h&quot;#include &quot;led.h&quot;#include &quot;key.h&quot;#include &quot;beep.h&quot;#include &quot;SysTick.h&quot;int main (void) { SysTick_Init(168); KEY_Init(); BEEP_Init(); LED_Init(); while (1) { if (Key1) { delay_ms(10); if (Key1) LED1_out = 1; delay_ms(10); }else{ LED1_out = 0; } if (Key3) { delay_ms(10); if (Key3) LED2_out = 1; delay_ms(10); }else{ LED2_out = 0; } if (Key2) { delay_ms(10); if (Key2) BEEP_On(); delay_ms(10); }else{ BEEP_Off(); } }} 参考链接 按键的硬件消抖电路原理","link":"/STM32F407-Learning-Note-12.html"},{"title":"STM32F407 Learning Note 13","text":"STM32中断系统 中断介绍 CPU执行程序时,由于发生了某种随机的事件(外部或内部),引起CPU暂时中断正在运行的程序,转去执行一段特殊的服务程序(中断服务子程序或中断处理程序),以处理该事件,这事件处理完后又返回被中断的程序继续执行,这一过程叫中断.引发中断的成为中断源.有些中断还能被其他优先级高的中断所中断,这种情况叫做中断的嵌套. NVIC介绍 NVIC(Nested Vectored Interrupt Controller, 嵌套向量控制器),属于M4内核的一个外设,控制着芯片的中断相关功能. 由于ARM给NVIC预留了非常多的功能,但对于使用M4内核设计芯片的公司可能就不需要这么多功能,于是就需要在NVIC上裁剪,ST公司的STM32F407芯片内部中断数量就是NVIC裁剪后的结果 中断控制相关寄存器在固件库core_cm4文件NVIC结构体内. 中断优先级 STM32F407芯片支持82个可屏蔽中断通道,每个中断通道都具备自己的中断优先级控制字节(8位,但是STM32F407中只使用4位,高四位有效),其优先级又分为抢占式优先级和响应式式优先级(通常也被称为&quot;亚优先级&quot;或&quot;副优先级&quot;),每个中断源都需要被指定这两种优先级. 高抢占式优先级的中断事件会打断当前的主程序或者中断程序运行俗称中断嵌套.在抢占式优先级相同的情况下,高响应式式优先级的中断优先被响应. 情况 处理方式 两个中断源的抢占式优先级相同时 这两个中断将没有嵌套关系,当一个中断到来后,如果正在处理另一个中断,这个后到来的中断就要等到前一个中断处理完后才能被处理 两个中断源的抢占式优先级相同,且两个中断同时到达 根据他们的响应式优先级高低来决定先处理哪一个 他们两种优先级都相同 根据他们在中断表中额排位顺序决定先处理哪一个 优先级组别 占先式优先级 副优先级 0 0位/0级 4位/16级 1 1位/0级 3位/8级 2 2位/4级 2位/4级 3 3位/8级 1位/2级 4 4位/16级 0位/0级 设置优先级分组可以调用库函数 NVIC_PriorityGroupConfig() EXTI介绍 EXTI(External Interrupt，STM32F4外部中断/事件控制器)包含多达23个用于产生中断/事件请求的边缘检测器.EXTI的每根输入线都可以单独进行配置,以选择选择类型(中断或事件)和响应的触发事件(上升沿触发,下降沿触发或边沿触发),还可单独屏蔽. EXTI线0~15连接到IO口的输入中断 外部事件/中断映射 EXTI线16连接到PVD输出 EXTI线17连接到RTC闹钟事件 EXTI线18连接到USB OTG FS唤醒事件 EXTI线19连接到以太网唤醒事件 EXTI线20连接到USB OTG HS(在FS中配置)唤醒事件 EXTI线21连接到RTC入侵和时间戳事件 EXTI线22连接到RTC唤醒事件 中断配置步骤 使能外设的某个中断 初始化 NVIC_InitTypeDef结构体,设置中断优先级分组 123456typedef struct { uint8_t NVIC_IRQChannel; // 中断源 uint8_t NVIC_IRQChannelPreemptionPriority; // 抢占式优先级 uint8_t NVIC_IRQChannelSubPriority; // 响应式优先级 FunctionalState NVIC_IRQChannelCmd; // 中断 使/失 能} NVIC_InitTypeDef; 编写中断服务 外部中断配置步骤 使能IO口时钟，配置IO口模式为输入 开启SYSCFG时钟，设置IO口与中断线的映射关系 1234// Enable SYSCFG periphRCC_APB2PeriphClockCMDClockCmd(RCC_APB2Periph_SYSCFG, ENABLE);// Configure EXTI linevoid SYSCFG_EXTILineConfig (uint8_t EXTI_PortSourceGPIOx, uint8_t EXTI_PinSourcex); 配置中断分组(NVIC),使能中断 初始化EXTI，选择触发方式 123456typedef struct { uint32_t EXTI_Line; // 中断/事件线 EXTIMode_TypeDef EXTI_Mode; // EXTI模式 EXTITrigger_TypeDef EXTI_Trigger; // EXTI触发方式 FunctionalState EXTI_LineCmd; // 中断线 使/失 能} EXTI_InitTypeDef; 编写EXTI中断服务函数 1234567EXTI0_IRQHandlerEXTI1_IRQHandlerEXTI2_IRQHandlerEXTI3_IRQHandlerEXTI4_IRQHandlerEXTI9_5_IRQHandlerEXTI15_10_IRQHandler 文中大量概念定义来自于B站普中STM32F407教学视频","link":"/STM32F407-Learning-Note-13.html"},{"title":"STM32F407 Learning Note 2","text":"STM32最小系统组成 电源电路 复位电路 晶振电路 下载电路 理论上前三个就已经足够了,只是方便下载程序需要添加下载电路 STM32 启动模式 启动模式选择引脚 启动模式 说明 BOOT0 BOOT1 0 x 主闪存存储器 主闪存存储器作为启动区域 1 0 系统存储器 系统存储器作为启动区域 1 1 内置SRAM 内置SRAM被选为启动区域 串口下载的程序一般是通过第二种模式运行普中的串口下载端口已经设置好了引脚,可以一键下载 存储器映射 存储器本身不具有地址信息,它的地址(4GB)由芯片厂商或用户分配,给存储器分配地址的过程称为存储器映射,如果再分配一个地址就叫重映射. 序号 用途 地址范围 Block 0 SRAM(Flash) 0x0000 0000 ~ 0x1FFF FFFF(512MB) Block 1 SRAM 0x2000 0000 ~ 0x3FFF FFFF(512MB) Block 2 片上外设 0x4000 0000 ~ 0x5FFF FFFF(512MB) Block 3 FSMC的 bank1 ~ bank2 0x6000 0000 ~ 0x7FFF FFFF(512MB) Block 4 FSMC的 bank3 ~ bank4 0x8000 0000 ~ 0x9FFF FFFF(512MB) Block 5 FSMC Registers 0xA000 0000 ~ 0xBFFF FFFF(512MB) Block 6 Not Used 0xC000 0000 ~ 0xDFFF FFFF(512MB) Block 7 Cortex-M4 内部外设 0xE000 0000 ~ 0xFFFF FFFF(512MB) 详情请见 &lt;STM32F407ZGT6数据手册.pdf&gt; 寄存器及寄存器映射 通过给有特定功能的内存单元起一个别名,这个别名就是我们所说的寄存器.给已经分配好地址的有特定功能的内存单元起别名的过程就叫寄存器映射. 访问寄存器内容 总线地址 总线名称 总线基地址 相对外设基地址的偏移 APB1 0x4000 0000 0x0000 0000 APB2 0x4001 0000 0x0001 0000 AHB1 0x4002 0000 0x0002 0000 AHB2 0x5000 0000 0x1000 0000 AHB3 0x6000 0000 已不属于片上外设 端口外设地址 外设名称 外设基地址 相对于AHB1总线的地址偏移 GPIOA 0x4002 0000 0x0000 0000 GPIOB 0x4002 0400 0x0000 0400 GPIOC 0x4002 0800 0x0000 0800 GPIOD 0x4002 0C00 0x0000 0C00 GPIOE 0x4002 1000 0x0000 1000 GPIOF 0x4002 1400 0x0000 1400 GPIOG 0x4002 1800 0x0000 1800 GPIOH 0x4002 1C00 0x0000 1C00 GPIOF端口的寄存器地址 寄存器名称 寄存器地址 相对于GPIOF基地址的偏移 GPIO_MODER 0x4002 1400 0x00 GPIO_OTYPER 0x4002 1404 0x04 GPIO_OSPEEDR 0x4002 1408 0x08 GPIO_PUPDR 0x4002 140C 0x0C GPIO_IDR 0x4002 1410 0x10 GPIO_ODR 0x4002 1414 0x14 GPIO_BSRR 0x4002 1418 0x18 GPIO_LCKR 0x4002 141C 0x1C GPIO_AFRL 0x4002 1420 0x20 GPIO_AFRH 0x4002 1424 0x24 详情请见 &lt;STM32F407ZGT6数据手册.pdf&gt; Set Register / Reset Register (GPIOx_BSRR) 置位寄存器 (Set Register) 置位寄存器(set register)用于将GPIO端口的某个或某些引脚置位,即将引脚的输出电平设置为高电平(1).当写入一个1到该寄存器的相应位时,该引脚的输出电平就会变为高电平. 复位寄存器 (Reset Register) 复位寄存器(reset register)用于将GPIO端口的某个或某些引脚复位,即将引脚的输出电平设置为低电平(0).当写入一个1到该寄存器的相应位时,该引脚的输出电平就会变为低电平. 区别 在操作上,置位寄存器和复位寄存器的区别在于其作用不同.置位寄存器将某个或某些引脚的输出电平设置为高电平,而复位寄存器则将某个或某些引脚的输出电平设置为低电平.在使用时,我们需要根据具体需求选择使用哪个寄存器来控制GPIO端口的引脚.","link":"/STM32F407-Learning-Note-2.html"},{"title":"STM32F407 Learning Note 4","text":"电容器在数字电路中的应用 Reprint : 单片机外围电路设计之二:电容 概念 电容(Capacitance) 亦称&quot;电容量&quot;,是指在给定电压下的电荷储存量,记为C,国际单位是法拉(F).电容是表现电容器容纳电荷本领的物理量.电容器从物理学上讲,它是一种静态电荷储存介质,可能电荷会永久存在,这是它的特征,他的用途较广,主要用于电源滤波,信号滤波,信号耦合,谐振,滤波,补偿,充放电,储能,隔直流等电路中. 常见分类 结构 固定电容器 可变电容器 微调电容器 介质种类 有机介质电容器 无机介质电容器 电解电容器 空气介质电容器 用途 高频旁路 陶瓷电容器 云母电容器 玻璃膜电容器 涤纶电容器 玻璃釉电容器 低频旁路 纸质电容器 陶瓷电容器 铝电解电容器 涤纶电容器 滤波 调谐 高频耦合 低频耦合 小型电容器 电容作用 电容器基本的作用就是充电和放电,但是由于这种基本充放电作用所延伸出来的许多电路现象,使得电容器有着种种不容的用途.例如:在电子马达中,用它来产生相位;在照相闪光灯中,用它来产生高能量的瞬间放电等等.下面是电容器在电子电路中的一些作用: 类型 作用 耦合电容 用在耦合电路中的电容称为耦合电容,在阻容耦合放大器和其他电容耦合电路中大量使用这种电容电路,起隔直流通交流作用 滤波电容 用在滤波电路中的电容器称为滤波电容,在电源滤波和各种滤波器电路中使用这种电容电路,滤波电容将一定频段内的信号从总信号中去除 退耦电容 用在退耦电路中的电容器称为退耦电容,在多级放大器的直流电压供给电路中使用这种电容电路,退耦电容消除每级放大器之间的有害低频交连 高频消振电容 用在高频消振电路中的电容称为高频消振电容,在音频负反馈放大器中,为了消振可能出现的高频自激,采用这种电容电路,以消除放大器可能出现的高频啸叫 谐振电容 用在LC谐振电路中的电容器称为谐振电容,LC并联和串联谐振电路中都需这种电容电路 旁路电容 用在旁路电路中的电容器称为旁路电容,电路中如果需要从信号中去掉某一频段的信号,可以使用旁路电容电路,根据所去掉信号频率不同,有全频域(所有交流信号)旁路电容电路和高频旁路电容电路 中和电容 用在中和电路中的电容器称为中和电容.在收音机高频和中频放大器,电视机高频放大器中,采用这种中和电容电路,以消除自激 定时电容 用在定时电路中的电容器称为定时电容.在需要通过电容充电,放电进行时间控制的电路中使用定时电容电路,电容起控制时间常数大小的作用 积分电容 用在积分电路中的电容器称为积分电容.在电势场扫描的同步分离电路中,采用这种积分电容电路,可以从场复合同步信号中取出场同步信号 微分电容 用在微分电路中的电容器称为微分电容.在触发器电路中为了得到尖顶触发信号,采用这种微分电容电路,以从各类(主要是矩形脉冲)信号中得到尖顶脉冲触发信号 补偿电容 用在补偿电路中的电容器称为补偿电容,在卡座的低音补偿电路中,使用这种低频补偿电容电路,以提升放音信号中的低频信号,此外,还有高频补偿电容电路 自举电容 用在自举电路中的电容器称为自举电容,常用的OTL功率放大器输出级电路采用这种自举电容电路,以通过正反馈的方式少量提升信号的正半周幅度 分频电容 在分频电路中的电容器称为分频电容,在音箱的扬声器分频电路中,使用分频电容电路,以使高频扬声器工作在高频段,中频扬声器工作在中频段,低频扬声器工作在低频段","link":"/STM32F407-Learning-Note-4.html"},{"title":"STM32F407 Learning Note 3","text":"二极管在数字电路中的应用 Reprint : 二极管的所有基础知识点 早期的二极管 早期的二极管包含&quot;猫须晶体&quot;(Cat’s Whisker Crystals)和真空管(ThermionicValves). 1904年,英国物理学家弗莱明根据&quot;爱迪生效应&quot;发明了世界上第一只电子二极管——真空电子二极管.它是依靠阴极热发射电子到阳极实现导通. 电源正负极接反则不能导电,它是一种能够单向传导电流的电子器件.早期电子二极管存在体积大,需预热,功耗大,易破碎等问题,促使了晶体二极管的发明. 晶体二极管 介绍 又称半导体二极管.1947年,美国人发明.在半导体二极管内部有一个PN结和两个引出端. 这种电子器件按照外加电压的方向,具备**单向电流的传导性**.现今最普遍的二极管大多是使用半导体材料如**硅**或**锗**. 结构 晶体二极管的核心是PN结 本征半导体:指不含任何掺杂元素的半导体,如纯硅晶片或纯锗晶片 P型半导体:掺杂了产生空穴的含较低电价杂质的半导体,如在本征半导体中Si(4+)中掺入Al(3+)的半导体 N型半导体:掺杂了产生电子的含较高电价杂质的半导体,如在本征半导体中硅Si(4+)中掺入磷P(5+)的半导体 由P型半导体和N型半导体相接触时,就产生一个独特的PN结界面,在界面的两侧形成空间电荷层,构成自建电场. 当外加电压等于零时,由于PN结两边载流子的浓度差引起扩散电流和由自建电场引起的漂移电流相等而处于电平衡状态,这也是常态下的PN结. 以PN结为核心结构,加上引线或引脚形成单向导电的二极管. 当外加电压方向由P极指向N极时,导通. 特性 二极管的伏安特性曲线如下: 外加电压Uw方向为P→N时,Uw大于起动电压,二极管导通; 外加电压Uw方向为N→P时,Uw大于反向击穿电压,二极管击穿. 性能参数 最大整流电流Idm:二极管连续工作允许通过的最大正向电流;电流过大,二极管会因过热烧毁;大电流整流可加装散热片. 最大反向电压Urm:Urm一般小于反向击穿电压,选规格以Urm为准,并留有余量;过电压易损坏二极管. 反向饱和电流Is:二极管外加反向电压时的电流值;Is反向击穿前很小,变化也很小;Is会随温度的升高而升高,一般地,常温下硅管Is&lt;1μA,锗管Is=30~300μA. 最高工作频率Fm:指二极管能保持良好工作特性的最高工作频率. 三极管在数字电路中的应用 Reprint : 三极管在数字电路中的应用 初步认识 三极管是一种常见的控制和驱动的器件 常用的三极管根据材料可以分为 硅管和锗管,两者原理相同,压降略有不同,前者用的比较普遍,而锗管应用较少,于是本文将使用硅管的参数进行阐述.三极管有两种类型:PNP型和NPN型,如下图, 三极管一共有三个极,从图来看,横向左侧的引脚叫做基极b(base),中间有个箭头,一头连着基极,一头连着发射极e(emitter),最后一个引脚则是集电极c(collector). 三极管的原理 三极管拥有三种工作模式:截至,放大,饱和 放大模式主要应用于模拟电路中,且用法和计算方法也比较复杂,我们暂时用不到.数字电路中主要使用的是三极管的开关特性,即只用到了截至和饱和两种状态. 用法特点: PNP: e极只要高于b极0.7V以上,e极和c极导通 NPN: b极只要高于e极0.7V以上,e极和c极导通 结论: 只要箭头的尾端高于箭头的头端0.7v即可接通e极和c极 饱和状态 条件: b极电流大于e极和c极之间的电流除以一个放大倍数$\\beta$ 对于放大倍数$\\beta$,对于常用的三极管打开可以认为是100, 这时候就要调整基极的阻流电阻来调整. 但是电阻值也不能太小,不然电流过大用以烧坏三极管 三极管的应用 三极管在数字电路里的开关特性,最常见的应用有两个:控制应用和驱动应用 控制: 图三中,三极管基极通过一个10K的电阻接到了单片机的一个IO口上,假定是P1.0,发射级直接接到5V的电源上,集电极接了一个LED小灯,并且串联了一个1K的限流电阻最终接到了电源负极GND上.如果P1.0由我们的程序给一个高电平1,那么基极b和发射极e都是5v,也就是说e到b不会产生一个0.7V的压降,这个时候发射极和集电极也就不会导通,那么这个电路在三极管处是断开的,没有电流通过,LED2小灯也不会亮.如果程序给P1.0一个低电平,这时e极还是5V,于是e和b之间产生了压差,三极管e和b之间也就导通了,三极管e和b之间大概有0.7V的压降,那么还有(5-0.7)V的电压会在电阻R47上.这个时候e和c之间也就导通了,那么LED小灯本身有2V的压降,三极管本身e和c之间大概有0.2V的压降,我们忽略不计.那么在R41上就会有大概3V的压降,可以计算出来.这条支路的电流大概是3mA,可以成功点亮LED灯 图4中,当IO口输出高电平为5V时,三极管导通,OUT输出低电平0V,当IO口输出低电平时,三极管截至,OUT则由上拉电阻R2的作用而输出12V的高电平,这样就实现了低电压控制高电压的工作原理 驱动 单片机的IO口可以输出一个高电平,但是它的输出电流却很有限,普通IO口输出高电平的时候,大概只有几十到几百uA的电流,达不到1mA,也就点不亮这个LED小灯或者是亮度很低,这个时候如果我们想用高电平点亮LED,就可以用上三极管来处理了,我们板上这种三极管型号可以通过500mA的电流,有的三极管通过的电流还更大一些,如图6所示,当IO口是高电平,三极管导通,因为三极管的电流放大作用,c极电流就可以达到mA以上了,就可以成功点亮LED小灯.","link":"/STM32F407-Learning-Note-3.html"},{"title":"STM32F407 Learning Note 5","text":"GPIO (General Purpose Input Output) GPIO (General Purpose Input Output) 是通用输入输出端口的简称,可以通过软件来控制其输入和输出.STM32芯片的GPIO引脚与外部设备连接起来,从而实现与外部通讯,控制以及数据采集的功能. GPIO 功能描述 输入 输入浮空 输入上拉 输入下拉 模拟功能 输出 推挽输出(具有上拉或下拉功能) 该模式下,输出口连接到一个推挽输出的引脚.引脚在输出高电平时与电源连接,在输出低电平时与地连接.该模式下输出电流能力强,适合驱动电感,LED等负载 开漏输出(具有上拉或下拉功能) 该模式下,输出口连接到一个开漏输出的引脚.引脚在输出高电平时断开,输出低电平时与地连接.该模式下输出电流能力较弱,但适用于驱动一些需要共用信号线的设备,如I2C总线 复用功能推挽(具有上拉或下拉功能) 复用功能开漏(具有上拉或下拉功能) GPIO 初始化步骤 确定GPIO模式:输入,通用输出,复用功能还是模拟输入(MODER) 确定GPIO输出类型:推挽输出还是开楼输出(OTYPER) 配置输出的速度(OSPEEDR) 输出的时候内部的上\\下拉电阻要不要开启(PUPDR) 具体输出的内容(BSRR,ODR)","link":"/STM32F407-Learning-Note-5.html"},{"title":"STM32F407 Learning Note 6","text":"使用寄存器点亮LED灯 原理图 我们可以知道如果我们需要点亮LED的话需要设置PF9,PF10引脚产生低电平 流程 使用RCC_AHB1ENR寄存器对GPIOF端口的时钟使能 使用GPIOF_MODER寄存器配置GPIOF引脚的工作模式 使用GPIOF_BSRR寄存器设置或者清除GPIOF引脚的输出状态 代码 stm32f4xx.h123456789101112131415161718192021222324252627#ifndef STM32F4XX_H#define STM32F4XX_H// Base Address#define PERIPH_BASE ((unsigned int)0x40000000)#define AHB1PERIPH_BASE (PERIPH_BASE + 0x00020000)#define GPIOF_BASE (AHB1PERIPH_BASE + 0x1400)#define RCC_BASE (AHB1PERIPH_BASE + 0x3800)// RCC Register Address#define RCC_AHB1ENR *(unsigned int *)(RCC_BASE + 0x30)// Registers Address#define GPIOF_MODER *(unsigned int *)(GPIOF_BASE + 0x00)#define GPIOF_OTYPER *(unsigned int *)(GPIOF_BASE + 0x04)#define GPIOF_OSPEEDER *(unsigned int *)(GPIOF_BASE + 0x08)#define GPIOF_PUPDR *(unsigned int *) (GPIOF_BASE + 0x0C)#define GPIOF_IDR *(unsigned int *) (GPIOF_BASE + 0x10)#define GPIOF_ODR *(unsigned int *) (GPIOF_BASE + 0x14)#define GPIOF_BSRR *(unsigned int *) (GPIOF_BASE + 0x18)#define GPIOF_LCKR *(unsigned int *) (GPIOF_BASE + 0x1C)#define GPIOF_AFRL *(unsigned int *) (GPIOF_BASE + 0x20)#define GPIOF_AFRH *(unsigned int *) (GPIOF_BASE + 0x24)#endif main.c1234567891011121314151617181920212223242526#include &quot;stm32f4xx.h&quot;typedef unsigned int u32;void delay (u32 i);void delay (u32 i) { while (i--) ;}int main (void) { RCC_AHB1ENR |= 1&lt;&lt;5; GPIOF_MODER |= (1&lt;&lt;(2*9))|(1&lt;&lt;(2*10)); while (1) { GPIOF_BSRR = (1&lt;&lt;(16+9))|(1&lt;&lt;(10)); delay(0x1FFFF); GPIOF_BSRR = (1&lt;&lt;(9))|(1&lt;&lt;(16+10)); delay(0x1FFFF); }} 编译 &amp; 下载","link":"/STM32F407-Learning-Note-6.html"},{"title":"STM32F407 Learning Note 7","text":"STM32F4xx固件库 CMSIS标准 CMSIS标准(Cortex Microcontroller Software Interface Standard) 是 ARM Cortex 微控制器软件接口. 固件库介绍 Reprint : STM32F4xx固件库的说明及使用 文件夹内容 内容介绍 Libraries文件夹 CMSIS文件夹 存放的是符合CMSIS规范的一些文件.包括 STM32F4xx核内外设访问层代码,DSP 软件库,RTOS API,以及STM32F4xx片上外设访问层代码等. STM32F4xx_StdPeriph_Driver文件夹 存放的是STM32F4xx标准外设固件库源码文件和对应的头文件.inc目录存放的是 stm32f4xx_ppp.h头文件,无需改动.src目录下面放的是stm32f4xx_ppp.c格式的固件库源码文件.每一个.c文件和一个相应的.h文件对应 Projects文件夹 由ST官方提供的固件实例源码 Utilities文件夹 官方评估板的一些对应源码 固件库说明 core_m4.h: CMSIS核心文件,提供进入M4内核接口由ARM公司提供,所有的CM4内核的芯片都适用 system_stm32f4xx.h: STM32F4片上外设访问层头文件,主要是系统寄存器定义申明以及包装内存操作 stm32f4xx_it.c,stm32f4xx_it.h, stm32f4xx_conf.h: 用来编写中断服务函数(中断服务函数也可以写在任意文件中) stm32f4xx_conf.h: 外设驱动配置文件 misc.c,misc.h,stm32f4xx_ppp.c,stm32f4xx_ppp.h 以及 stm32f4xx_rcc.c 和stm32f4xx_rcc.h: STM32F4xx标准的外设库文件.misc.c和misc.h是定义中断优先级分组和Systick定时器相关的函数stm32f3xx_rcc.c和stm32f4xx_rcc.h是与 RCC 相关的一些操作函数,作用主要是一些时钟的配置和使能.在任何一个 STM32 工程 RCC 相关的源文件和头文件是必须添加的.stm32f4xx_ppp.c和stm32f4xx_ppp.h是STM32F4xx标准外设固件库对应的源文件和头文件,包括一些常用外设 GPIO,ADC,USART 等 Application.c: 应用层代码 使用库函数点亮LED GPIO库函数介绍 GPIO外设的库文件 stm32f4xx_gpio.c stm32f4xx_gpio.h GPIO常用库函数 12345678910111213141516171819202122/* Function used to set the GPIO configuration to the default reset state ****/void GPIO_DeInit(GPIO_TypeDef* GPIOx);/* Initialization and Configuration functions *********************************/void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);void GPIO_StructInit(GPIO_InitTypeDef* GPIO_InitStruct);void GPIO_PinLockConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);/* GPIO Read and Write functions ***************************************** *****/uint8_t GPIO_ReadInputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);uint16_t GPIO_ReadInputData (GPIO_TypeDef* GPIOx);uint8_t GPIO_ReadOutputDataBit (GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);uint16_t GPIO_ReadOutputData (GPIO_TypeDef* GPIOx);void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal);void GPIO_ToggleBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin);/* GPIO Alternate functions configuration function ****************************/void GPIO_PinAFConfig(GPIO_TypeDef* GPIOx, uint16_t GPIO_PinSource, uint8_t GPIO_AF); 初始化函数 1void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct) 功能: 初始化一个或多个IO口(同一组端口)的工作模式,输出速度,输出类型,上下拉模式,即GPIO的4个配置寄存器. 初始化范例 12345678GPIO_InitTypeDef GPIO_InitStructure; // 定义结构体变量GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT; // 输出模式GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; // 管脚设置F9GPIO_InitStructure.GPIO_Speed= GPIO_Speed_100MHz; //速度为100MHzGPIO_InitStructure.GPIO_OType = GPIO_OType_PP; // 推挽输出GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP; // 上拉GPIO_Init(GPIOF, &amp;GPIO_InitStructure); // 初始化结构体 设置管脚输出电平函数 1void GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 功能: 设置某个IO口为高电平(可同时设置同一端口的多个IO).底层是通过配置BSRR寄存器. 1void GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 功能: 设置某个IO口为低电平(可同时设置同一端口的多个IO).底层是通过配置BSRR寄存器. 12void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal);void GPIO_Write(GPIO_TypeDef* GPIOx, uint16_t PortVal); 功能: 设置端口管脚输出电平,很少使用. 读取管脚输入电平函数 1uint8_t GPIO_ReadInputDataBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin); 功能: 读取端口中的某个管脚输入电平.底层是通过读取IDR寄存器. 1uint16_t GPIO_ReadInputData(GPIO_TypeDef* GPIOx); 功能: 读取某组端口的输入电平.底层是通过读取IDR寄存器. 使能GPIO时钟函数 1RCC_AHB1PeriphClockCmd(uint32_t RCC_AHB1Periph, FunctionalState NewState); 功能: 使能AHB1总线上的外设 使能范例1RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOF, ENABLE);","link":"/STM32F407-Learning-Note-7.html"},{"title":"STM32F407 Learning Note 8","text":"RCC 类型 系统复位 电源复位 备份域复位 系统复位 除了CSR(时钟控制寄存器)中的复位标志和备份域中的寄存器外,系统复位会将其他全部寄存器都复位为复位值. 产生原因: NRST引脚低电平 (外部复位) 窗口看门狗技术结束 (WWDG复位) 独立看门狗技术结束 (IWDG复位) 软件复位 (SW复位) 低功耗管理复位 软件复位 可通过查看 RCC_CSR(RCC时钟控制和状态寄存器) 中的复位标志确定 要对器件进行软件复位,必须将Cortex-M4F 应用中断和复位控制寄存器中的SYSRESETREQ位置1. 低功耗管理复位 两种引发方式: 进入待机模式时产生复位 进入停止模式时产生复位 时钟 可以使用三种不同的时钟源来驱动系统时钟(SYSCLK): HSI 振荡器时钟 HSE 振荡器时钟 主PLL 时钟 器件具有以下两种次级时钟源: LSI RC(32kHz 低速内部RC) 该RC用于驱动独立看门狗,也可选择提供给RTC用于停机/待机模式下的自动唤醒 LSE 晶振(32.768kHz 低速外部晶振) 该晶振用于驱动RTCCLK(RTC时钟) 对于每个时钟源来说,在未使用时都可以单独打开或者关闭,以降低功耗.","link":"/STM32F407-Learning-Note-8.html"},{"title":"STM32F407 Learning Note 9","text":"时钟配置函数介绍 时钟使能配置函数 时钟源和分频因子相关配置函数 外设复位函数 参数状态获取函数 RCC中断相关函数 RCC_HSICmd RCC_LSICmd RCC_PLLCmd RCC_PLLI2SCmd RCC_PLLSAICmd RCC_RTCCLKCmd RCC_AHBxPeriphClockCmd RCC_APBxPeriphClockCmd RCC_HSEConfig RCC_LSEConfig RCC_PLLConfig RCC_PLLI2SConfig RCC_PLLSAIConfig RCC_MC01Config RCC_MC02Config RCC_SYSCLKConfig RCC_HCLKConfig RCC_PCLK1Config RCC_PCLK2Config RCC_RTCCLKConfig RCC_I2SCLKConfig RCC_AHB1ResetCmd RCC_AHB2ResetCmd RCC_AHB3ResetCmd RCC_APB1ResetCmd RCC_APB2ResetCmd RCC_GetSYSCLKSource RCC_GetClocksFreq RCC_GetFlagStatus RCC_ClearFlag RCC_ITConfig RCC_GetITStatus RCC_ClearITPendingBit HSE时钟配置函数代码实现 12345678910111213141516void RCC_HSE_Config (u32 pllm, u32 plln, u32 pllp, u32 pllq) { RCC_DeInit(); // 将外设RCC寄存器重设位缺省值 RCC_HSEConfig(RCC_HSE_ON); // 设置外部高速晶振(HSE) if (RCC_WaitForHSEStartUp()==SUCCESS) { RCC_HCLKConfig(RCC_SYSCLK_Div1); //设置APHB时钟(HCLK) RCC_PCLK1Config(RCC_HCLK_Div4); // 设置低速APB1时钟(PCLK1) RCC_PCLK2Config(RCC_HCLK_Div2); // 设置低速APB1时钟(PCLK2) RCC_PLLConfig(RCC_PLLSource_HSE, pllm, plln, pllp, pllq); // 设置PLL时钟源及倍频系数 RCC_PLLCmd(ENABLE); // 使能PLL while (RCC_GetFlagStatus(RCC_FLAG_PLLRDY)==RESET); // 检查指定RCC标志位设置与否 RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK); // 设置系统时钟(SYSCLK) while (RCC_GetSYSCLKSource()!=0x08); // 等待至PLL作为系统时钟 }} 位带介绍 位带操作 通过将每个比特位膨胀成一个32位字,当访问这些字的时候就达到了啊访问比特的目的. STM32 位带及位带别名区域 支持位带操作的区域是SRAM区的最低1MB范围(APB1,APB2,AHB1外设)和片内外设区的最低1MB范围 即1MB区域膨胀为32MB的别名区域 位带区与位带别名区地址转换 外设位带区 $$ AliasAddr = 0x42000000+(A-0x40000000)84+n*4 $$ SRAM位带区 $$ AliasAddr = 0x22000000+(A-0x20000000)84+n*4 $$ Note: A: 表示要操作的那个位所在的寄存器的地址 n: 表示为序号 统一公式 $$ AliasAddr = ((A&amp;0xF0000000)+0x02000000+(((A&amp;000FFFFF)&lt;&lt;5)+(n&lt;&lt;2))) $$ 位带操作的优点 控制GPIO口输入输出非常简单 操作串行接口芯片非常方便 代码简洁,阅读方便","link":"/STM32F407-Learning-Note-9.html"},{"title":"STM32F407 Learning Note","text":"此学习笔记使用的开发板是 普中STM32F407ZGT6 学习资料 下载地址为 普中科技 学习视频 【普中教程视频】STM32F4开发板(完整版) 目录 命名规则 架构 学习方法 STM32-启动模式 存储器映射 寄存器及寄存器映射 二极管在数字电路中的应用 三极管在数字电路中的应用 电容器在数字电路中的应用 GPIO (General Purpose Input Output) 使用寄存器点亮LED灯 STM32F4xx固件库 使用库函数点亮LED 使用库函数点亮LED 系统复位 时钟配置函数介绍 位带介绍 SysTick系统定时器 蜂鸣器介绍 蜂鸣器模块电路 蜂鸣器代码实现 按键介绍","link":"/STM32F407-Learning-Note.html"},{"title":"Upgarade the version of NodeJS","text":"The following operations is not helpful for Windows User. Steps: 1. Install the global manager n 1npm install -g n 2. Upgrade the version of node 12345678# if you want to upgrade to specified versionn &lt;version&gt; # e.g. n 10.0.0# install the latest versionn latest# install the latest stable versionn stable 3. Test 12$ node -vv19.9.0 4. Epilogue If you are Linux User, the former steps perfectly fits you, but if you are Windows User, you have to download the installation package specifically.","link":"/Upgarade-the-version-of-NodeJS.html"},{"title":"Upgrade Windows 10 to 11","text":"For inconvenience of Linux about playing games, I finally change my os from Kali Linux to Windows. But since the version I installed is Windows 10 which is not supporting all the latest features, I had to upgrade my Windows to Windows 11. Steps: 1. Download Windows 11 Installation Assistant open Microsoft’s Installation Website download the assistant executable upgrade your OS and wait till the installation is over 2. Join the Windows Preview Experience Plan open the setting and click the “Upgrade and Security” click “Windows Preview Experience Plan” if your window shows blank resembling as follows: open “Windows Powershell (Admin)” and type 12345$path = &quot;HKLM:\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\DataCollection&quot;# Telemetry level: 1 - basic, 3 - full$value = &quot;3&quot;New-ItemProperty -Path $path -Name AllowTelemetry -Value $value -Type Dword -ForceNew-ItemProperty -Path $path -Name MaxTelemetryAllowed -Value $value -Type Dword -Force reopen “Windows Preview Experience Plan” and you can see: and join the plan. 3. Upgrade the Windows open the setting of Windows Upgrade 4. Use it !","link":"/Upgrade-Windows-10-to-11.html"},{"title":"Windows Fast Boot -&gt; Linux Mount Error","text":"Problems Today, while I’m prepare to mount my Windows disk on my Kali and write a post. A Problems occurred as follows. 123456The disk contains an unclean file system (0, 0).Metadata kept in Windows cache, refused to mount.Failed to mount '/dev/sda1': Operation not permittedThe NTFS partition is in an unsafe state. Please resume and shutdownWindows fully (no hibernation or fast restarting), or mount the volumeread-only with the 'ro' mount option. After searching online, I knew it was the problem resulted from Windows Fast Boot. You can’t mount your Windows drives read-write in Linux, when Windows Fast Boot is enabled, since Windows won’t flush latest updates to disk when shutting down but keep them in a state-file, so the filesystem will not be in a consistent state. So if you wanna mount your Windows drivers, you should disable Windows Fast Boot in your Windows. Solution Shut down Windows Fast Boot run the reg code in your Windows 123456789Windows Registry Editor Version 5.00; Created by: Shawn Brink; Edited by: AzarAI; Created on: September 4, 2021; Tutorial: https://www.elevenforum.com/t/turn-on-or-off-fast-startup-in-windows-11.1212/[HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power]&quot;HiberbootEnabled&quot;=dword:00000000 ; if you wanna enable that change number to 1 shutdown Windows and run your Linux mount the partition","link":"/Windows-Fast-Boot-Linux-Mount-Error.html"},{"title":"Xinput Configuration for Three-finger Touch","text":"Today we’ll stimulate the Win touchpad actions to configure my linux to enable tree-fingers touchpad operation with libinput-gesture Get the information of Touchpad 1$ xinput list 1$ xinput --list-props &quot;13&quot; Install the libinput-gesture Install the dependencies 1$ sudo apt install xdotool wmctrl Install the libinput-gesture 123$ git clone https://github.com/bulletmark/libinput-gestures.git$ cd libinput-gestures$ sudo ./libinput-gestures-setup install If you are happy with the default configuration, you could’t type the following: 1$ libinput-gesture autostart start Configuration The default gesture configurations are in /etc/libinput-gesture.conf, and if you want to create your own custom gestures the copy the file to ~/.config/libinput-gesture.conf and edit it. The followings are the available gestures: Gesture Example Mapping Swipe up KDE/GNOME move to the next workspace Swipe down KDE/GNOME move to the previous workspace Swipe left Swipe right Pinch in GNOME open/close overview Pinch out GNOME open/close overview Pinch clockwise Pinch anticlockwise Hold on You can choose to specify a specific finger count, typically 3 or more fingers for swipe or pinch.Gestures specified with finger count have priority over the same gesture specified without any finger count. configure Open the file 1$ vim /etc/libinput-gesture Edit the gesture you want, as for me I’ll add 3-fingers gestures to implement some operations. 12345678910# Switch to the Desktopgesture swipe down 3 xdotool key super+d# Swith the workspacegesture swipe left 4 xdotool key ctrl+alt+Rightgesture swipe right 4 xdotool key ctrl+alt+Left# Reduce or enlargegesture pinch in 2 xdotool key ctrl+miniusgesture pinch out 2 xdotool key ctrl+plus Relevant refrence Blog-陆道峰:kde5与archlinux环境下配置libinput-gestures多手势操作 Github: libinput-gesture Libinput: Gestures","link":"/Xinput-Configuration-for-Three-finger-Touch.html"}],"tags":[{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Sequential Tables","slug":"Sequential-Tables","link":"/tags/Sequential-Tables/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Assembler","slug":"Assembler","link":"/tags/Assembler/"},{"name":"Cycle List","slug":"Cycle-List","link":"/tags/Cycle-List/"},{"name":"Firmware","slug":"Firmware","link":"/tags/Firmware/"},{"name":"CMake","slug":"CMake","link":"/tags/CMake/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Render","slug":"Render","link":"/tags/Render/"},{"name":"Prettifly","slug":"Prettifly","link":"/tags/Prettifly/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Commands","slug":"Commands","link":"/tags/Commands/"},{"name":"sudo","slug":"sudo","link":"/tags/sudo/"},{"name":"NeuralNetwork","slug":"NeuralNetwork","link":"/tags/NeuralNetwork/"},{"name":"MNIST","slug":"MNIST","link":"/tags/MNIST/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"STM32","slug":"STM32","link":"/tags/STM32/"},{"name":"Develop Environment","slug":"Develop-Environment","link":"/tags/Develop-Environment/"},{"name":"STM32F407","slug":"STM32F407","link":"/tags/STM32F407/"},{"name":"Windows","slug":"Windows","link":"/tags/Windows/"},{"name":"Touchpad","slug":"Touchpad","link":"/tags/Touchpad/"}],"categories":[{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Assembler","slug":"Assembler","link":"/categories/Assembler/"},{"name":"Firmware","slug":"Firmware","link":"/categories/Firmware/"},{"name":"CMake","slug":"CMake","link":"/categories/CMake/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Machine Learning","slug":"Machine-Learning","link":"/categories/Machine-Learning/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"NodeJS","slug":"NodeJS","link":"/categories/NodeJS/"},{"name":"STM32","slug":"STM32","link":"/categories/STM32/"},{"name":"Prettify","slug":"Hexo/Prettify","link":"/categories/Hexo/Prettify/"},{"name":"Commands","slug":"Linux/Commands","link":"/categories/Linux/Commands/"},{"name":"NeuralNetwork","slug":"Machine-Learning/NeuralNetwork","link":"/categories/Machine-Learning/NeuralNetwork/"},{"name":"Math Tokens","slug":"Markdown/Math-Tokens","link":"/categories/Markdown/Math-Tokens/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Prettify","slug":"Linux/Prettify","link":"/categories/Linux/Prettify/"},{"name":"F407","slug":"STM32/F407","link":"/categories/STM32/F407/"},{"name":"upgrade 10 to 11","slug":"Windows/upgrade-10-to-11","link":"/categories/Windows/upgrade-10-to-11/"},{"name":"Problems","slug":"Linux/Problems","link":"/categories/Linux/Problems/"}],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}